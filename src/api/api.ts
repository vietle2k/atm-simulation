// / <reference path="./custom.d.ts" />
// tslint:disable
/**
 * openHAB REST API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

export const BASE_PATH = 'http://peterserver1.myvnc.com:8080/rest'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|'
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration = new Configuration();

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name = 'RequiredError';

  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface AudioSinkDTO
 */
export interface AudioSinkDTO {
  /**
   *
   * @type {string}
   * @memberof AudioSinkDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AudioSinkDTO
   */
  label?: string;
}

/**
 *
 * @export
 * @interface AudioSourceDTO
 */
export interface AudioSourceDTO {
  /**
   *
   * @type {string}
   * @memberof AudioSourceDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AudioSourceDTO
   */
  label?: string;
}

/**
 *
 * @export
 * @interface BindingInfoDTO
 */
export interface BindingInfoDTO {
  /**
   *
   * @type {string}
   * @memberof BindingInfoDTO
   */
  author?: string;
  /**
   *
   * @type {string}
   * @memberof BindingInfoDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof BindingInfoDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof BindingInfoDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BindingInfoDTO
   */
  configDescriptionURI?: string;
}

/**
 *
 * @export
 * @interface ChannelDTO
 */
export interface ChannelDTO {
  /**
   *
   * @type {string}
   * @memberof ChannelDTO
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelDTO
   */
  channelTypeUID?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelDTO
   */
  itemType?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelDTO
   */
  kind?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelDTO
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ChannelDTO
   */
  defaultTags?: Array<string>;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ChannelDTO
   */
  properties?: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ChannelDTO
   */
  configuration?: { [key: string]: any };
}

/**
 *
 * @export
 * @interface ChannelDefinitionDTO
 */
export interface ChannelDefinitionDTO {
  /**
   *
   * @type {string}
   * @memberof ChannelDefinitionDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelDefinitionDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelDefinitionDTO
   */
  label?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ChannelDefinitionDTO
   */
  tags?: Array<string>;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ChannelDefinitionDTO
   */
  properties?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof ChannelDefinitionDTO
   */
  category?: string;
  /**
   *
   * @type {StateDescription}
   * @memberof ChannelDefinitionDTO
   */
  stateDescription?: StateDescription;
  /**
   *
   * @type {boolean}
   * @memberof ChannelDefinitionDTO
   */
  advanced?: boolean;
  /**
   *
   * @type {string}
   * @memberof ChannelDefinitionDTO
   */
  typeUID?: string;
}

/**
 *
 * @export
 * @interface ChannelGroupDefinitionDTO
 */
export interface ChannelGroupDefinitionDTO {
  /**
   *
   * @type {string}
   * @memberof ChannelGroupDefinitionDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelGroupDefinitionDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelGroupDefinitionDTO
   */
  label?: string;
  /**
   *
   * @type {Array<ChannelDefinitionDTO>}
   * @memberof ChannelGroupDefinitionDTO
   */
  channels?: Array<ChannelDefinitionDTO>;
}

/**
 *
 * @export
 * @interface ChannelTypeDTO
 */
export interface ChannelTypeDTO {
  /**
   *
   * @type {Array<ConfigDescriptionParameterDTO>}
   * @memberof ChannelTypeDTO
   */
  parameters?: Array<ConfigDescriptionParameterDTO>;
  /**
   *
   * @type {Array<ConfigDescriptionParameterGroupDTO>}
   * @memberof ChannelTypeDTO
   */
  parameterGroups?: Array<ConfigDescriptionParameterGroupDTO>;
  /**
   *
   * @type {string}
   * @memberof ChannelTypeDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelTypeDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelTypeDTO
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelTypeDTO
   */
  itemType?: string;
  /**
   *
   * @type {string}
   * @memberof ChannelTypeDTO
   */
  kind?: string;
  /**
   *
   * @type {StateDescription}
   * @memberof ChannelTypeDTO
   */
  stateDescription?: StateDescription;
  /**
   *
   * @type {Array<string>}
   * @memberof ChannelTypeDTO
   */
  tags?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ChannelTypeDTO
   */
  UID?: string;
  /**
   *
   * @type {boolean}
   * @memberof ChannelTypeDTO
   */
  advanced?: boolean;
  /**
   *
   * @type {CommandDescription}
   * @memberof ChannelTypeDTO
   */
  commandDescription?: CommandDescription;
}

/**
 *
 * @export
 * @interface CommandDescription
 */
export interface CommandDescription {
  /**
   *
   * @type {Array<CommandOption>}
   * @memberof CommandDescription
   */
  commandOptions?: Array<CommandOption>;
}

/**
 *
 * @export
 * @interface CommandOption
 */
export interface CommandOption {
  /**
   *
   * @type {string}
   * @memberof CommandOption
   */
  command?: string;
  /**
   *
   * @type {string}
   * @memberof CommandOption
   */
  label?: string;
}

/**
 *
 * @export
 * @interface ConfigDescriptionDTO
 */
export interface ConfigDescriptionDTO {
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionDTO
   */
  uri?: string;
  /**
   *
   * @type {Array<ConfigDescriptionParameterDTO>}
   * @memberof ConfigDescriptionDTO
   */
  parameters?: Array<ConfigDescriptionParameterDTO>;
  /**
   *
   * @type {Array<ConfigDescriptionParameterGroupDTO>}
   * @memberof ConfigDescriptionDTO
   */
  parameterGroups?: Array<ConfigDescriptionParameterGroupDTO>;
}

/**
 *
 * @export
 * @interface ConfigDescriptionParameterDTO
 */
export interface ConfigDescriptionParameterDTO {
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  context?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  defaultValue?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof ConfigDescriptionParameterDTO
   */
  required?: boolean;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  type?: ConfigDescriptionParameterDTO.TypeEnum;
  /**
   *
   * @type {number}
   * @memberof ConfigDescriptionParameterDTO
   */
  min?: number;
  /**
   *
   * @type {number}
   * @memberof ConfigDescriptionParameterDTO
   */
  max?: number;
  /**
   *
   * @type {number}
   * @memberof ConfigDescriptionParameterDTO
   */
  stepsize?: number;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  pattern?: string;
  /**
   *
   * @type {boolean}
   * @memberof ConfigDescriptionParameterDTO
   */
  readOnly?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ConfigDescriptionParameterDTO
   */
  multiple?: boolean;
  /**
   *
   * @type {number}
   * @memberof ConfigDescriptionParameterDTO
   */
  multipleLimit?: number;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  groupName?: string;
  /**
   *
   * @type {boolean}
   * @memberof ConfigDescriptionParameterDTO
   */
  advanced?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ConfigDescriptionParameterDTO
   */
  verify?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ConfigDescriptionParameterDTO
   */
  limitToOptions?: boolean;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  unit?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterDTO
   */
  unitLabel?: string;
  /**
   *
   * @type {Array<ParameterOptionDTO>}
   * @memberof ConfigDescriptionParameterDTO
   */
  options?: Array<ParameterOptionDTO>;
  /**
   *
   * @type {Array<FilterCriteriaDTO>}
   * @memberof ConfigDescriptionParameterDTO
   */
  filterCriteria?: Array<FilterCriteriaDTO>;
}

/**
 * @export
 * @namespace ConfigDescriptionParameterDTO
 */
export namespace ConfigDescriptionParameterDTO {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    TEXT = <any>'TEXT',
    INTEGER = <any>'INTEGER',
    DECIMAL = <any>'DECIMAL',
    BOOLEAN = <any>'BOOLEAN'
  }
}

/**
 *
 * @export
 * @interface ConfigDescriptionParameterGroupDTO
 */
export interface ConfigDescriptionParameterGroupDTO {
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterGroupDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterGroupDTO
   */
  context?: string;
  /**
   *
   * @type {boolean}
   * @memberof ConfigDescriptionParameterGroupDTO
   */
  advanced?: boolean;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterGroupDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigDescriptionParameterGroupDTO
   */
  description?: string;
}

/**
 *
 * @export
 * @interface ConfigurableServiceDTO
 */
export interface ConfigurableServiceDTO {
  /**
   *
   * @type {string}
   * @memberof ConfigurableServiceDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigurableServiceDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigurableServiceDTO
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof ConfigurableServiceDTO
   */
  configDescriptionURI?: string;
  /**
   *
   * @type {boolean}
   * @memberof ConfigurableServiceDTO
   */
  multiple?: boolean;
}

/**
 *
 * @export
 * @interface DiscoveryResultDTO
 */
export interface DiscoveryResultDTO {
  /**
   *
   * @type {string}
   * @memberof DiscoveryResultDTO
   */
  bridgeUID?: string;
  /**
   *
   * @type {string}
   * @memberof DiscoveryResultDTO
   */
  flag?: DiscoveryResultDTO.FlagEnum;
  /**
   *
   * @type {string}
   * @memberof DiscoveryResultDTO
   */
  label?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof DiscoveryResultDTO
   */
  properties?: { [key: string]: any };
  /**
   *
   * @type {string}
   * @memberof DiscoveryResultDTO
   */
  representationProperty?: string;
  /**
   *
   * @type {string}
   * @memberof DiscoveryResultDTO
   */
  thingUID?: string;
  /**
   *
   * @type {string}
   * @memberof DiscoveryResultDTO
   */
  thingTypeUID?: string;
}

/**
 * @export
 * @namespace DiscoveryResultDTO
 */
export namespace DiscoveryResultDTO {
  /**
   * @export
   * @enum {string}
   */
  export enum FlagEnum {
    NEW = <any>'NEW',
    IGNORED = <any>'IGNORED'
  }
}

/**
 *
 * @export
 * @interface EnrichedItemDTO
 */
export interface EnrichedItemDTO {
  /**
   *
   * @type {string}
   * @memberof EnrichedItemDTO
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof EnrichedItemDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof EnrichedItemDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof EnrichedItemDTO
   */
  category?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof EnrichedItemDTO
   */
  tags?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof EnrichedItemDTO
   */
  groupNames?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof EnrichedItemDTO
   */
  link?: string;
  /**
   *
   * @type {string}
   * @memberof EnrichedItemDTO
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof EnrichedItemDTO
   */
  transformedState?: string;
  /**
   *
   * @type {StateDescription}
   * @memberof EnrichedItemDTO
   */
  stateDescription?: StateDescription;
  /**
   *
   * @type {CommandDescription}
   * @memberof EnrichedItemDTO
   */
  commandDescription?: CommandDescription;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof EnrichedItemDTO
   */
  metadata?: { [key: string]: any };
  /**
   *
   * @type {boolean}
   * @memberof EnrichedItemDTO
   */
  editable?: boolean;
}

/**
 *
 * @export
 * @interface EnrichedThingDTO
 */
export interface EnrichedThingDTO {
  /**
   *
   * @type {string}
   * @memberof EnrichedThingDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof EnrichedThingDTO
   */
  bridgeUID?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof EnrichedThingDTO
   */
  configuration?: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EnrichedThingDTO
   */
  properties?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof EnrichedThingDTO
   */
  UID?: string;
  /**
   *
   * @type {string}
   * @memberof EnrichedThingDTO
   */
  thingTypeUID?: string;
  /**
   *
   * @type {Array<ChannelDTO>}
   * @memberof EnrichedThingDTO
   */
  channels?: Array<ChannelDTO>;
  /**
   *
   * @type {string}
   * @memberof EnrichedThingDTO
   */
  location?: string;
  /**
   *
   * @type {ThingStatusInfo}
   * @memberof EnrichedThingDTO
   */
  statusInfo?: ThingStatusInfo;
  /**
   *
   * @type {FirmwareStatusDTO}
   * @memberof EnrichedThingDTO
   */
  firmwareStatus?: FirmwareStatusDTO;
  /**
   *
   * @type {boolean}
   * @memberof EnrichedThingDTO
   */
  editable?: boolean;
}

/**
 *
 * @export
 * @interface EventOutput
 */
export interface EventOutput {
  /**
   *
   * @type {Type}
   * @memberof EventOutput
   */
  type?: Type;
  /**
   *
   * @type {boolean}
   * @memberof EventOutput
   */
  closed?: boolean;
}

/**
 *
 * @export
 * @interface FilterCriteriaDTO
 */
export interface FilterCriteriaDTO {
  /**
   *
   * @type {string}
   * @memberof FilterCriteriaDTO
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof FilterCriteriaDTO
   */
  name?: string;
}

/**
 *
 * @export
 * @interface FirmwareStatusDTO
 */
export interface FirmwareStatusDTO {
  /**
   *
   * @type {string}
   * @memberof FirmwareStatusDTO
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof FirmwareStatusDTO
   */
  updatableVersion?: string;
}

/**
 *
 * @export
 * @interface GroupFunctionDTO
 */
export interface GroupFunctionDTO {
  /**
   *
   * @type {string}
   * @memberof GroupFunctionDTO
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GroupFunctionDTO
   */
  params?: Array<string>;
}

/**
 *
 * @export
 * @interface GroupItemDTO
 */
export interface GroupItemDTO {
  /**
   *
   * @type {string}
   * @memberof GroupItemDTO
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof GroupItemDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof GroupItemDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof GroupItemDTO
   */
  category?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GroupItemDTO
   */
  tags?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof GroupItemDTO
   */
  groupNames?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof GroupItemDTO
   */
  groupType?: string;
  /**
   *
   * @type {GroupFunctionDTO}
   * @memberof GroupItemDTO
   */
  _function?: GroupFunctionDTO;
}

/**
 *
 * @export
 * @interface HistoryDataBean
 */
export interface HistoryDataBean {
  /**
   *
   * @type {number}
   * @memberof HistoryDataBean
   */
  time?: number;
  /**
   *
   * @type {string}
   * @memberof HistoryDataBean
   */
  state?: string;
}

/**
 *
 * @export
 * @interface HumanLanguageInterpreterDTO
 */
export interface HumanLanguageInterpreterDTO {
  /**
   *
   * @type {string}
   * @memberof HumanLanguageInterpreterDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof HumanLanguageInterpreterDTO
   */
  label?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof HumanLanguageInterpreterDTO
   */
  locales?: Array<string>;
}

/**
 *
 * @export
 * @interface ItemChannelLinkDTO
 */
export interface ItemChannelLinkDTO {
  /**
   *
   * @type {string}
   * @memberof ItemChannelLinkDTO
   */
  itemName?: string;
  /**
   *
   * @type {string}
   * @memberof ItemChannelLinkDTO
   */
  channelUID?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ItemChannelLinkDTO
   */
  configuration?: { [key: string]: any };
}

/**
 *
 * @export
 * @interface ItemHistoryDTO
 */
export interface ItemHistoryDTO {
  /**
   *
   * @type {string}
   * @memberof ItemHistoryDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ItemHistoryDTO
   */
  totalrecords?: string;
  /**
   *
   * @type {string}
   * @memberof ItemHistoryDTO
   */
  datapoints?: string;
  /**
   *
   * @type {Array<HistoryDataBean>}
   * @memberof ItemHistoryDTO
   */
  data?: Array<HistoryDataBean>;
}

/**
 *
 * @export
 * @interface MappingDTO
 */
export interface MappingDTO {
  /**
   *
   * @type {string}
   * @memberof MappingDTO
   */
  command?: string;
  /**
   *
   * @type {string}
   * @memberof MappingDTO
   */
  label?: string;
}

/**
 *
 * @export
 * @interface MetadataDTO
 */
export interface MetadataDTO {
  /**
   *
   * @type {string}
   * @memberof MetadataDTO
   */
  value?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof MetadataDTO
   */
  config?: { [key: string]: any };
}

/**
 *
 * @export
 * @interface PageDTO
 */
export interface PageDTO {
  /**
   *
   * @type {string}
   * @memberof PageDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PageDTO
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof PageDTO
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof PageDTO
   */
  link?: string;
  /**
   *
   * @type {PageDTO}
   * @memberof PageDTO
   */
  parent?: PageDTO;
  /**
   *
   * @type {boolean}
   * @memberof PageDTO
   */
  leaf?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PageDTO
   */
  timeout?: boolean;
  /**
   *
   * @type {Array<WidgetDTO>}
   * @memberof PageDTO
   */
  widgets?: Array<WidgetDTO>;
}

/**
 *
 * @export
 * @interface ParameterOptionDTO
 */
export interface ParameterOptionDTO {
  /**
   *
   * @type {string}
   * @memberof ParameterOptionDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ParameterOptionDTO
   */
  value?: string;
}

/**
 *
 * @export
 * @interface ProfileTypeDTO
 */
export interface ProfileTypeDTO {
  /**
   *
   * @type {string}
   * @memberof ProfileTypeDTO
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof ProfileTypeDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ProfileTypeDTO
   */
  kind?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ProfileTypeDTO
   */
  supportedItemTypes?: Array<string>;
}

/**
 *
 * @export
 * @interface SitemapDTO
 */
export interface SitemapDTO {
  /**
   *
   * @type {string}
   * @memberof SitemapDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof SitemapDTO
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof SitemapDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof SitemapDTO
   */
  link?: string;
  /**
   *
   * @type {PageDTO}
   * @memberof SitemapDTO
   */
  homepage?: PageDTO;
}

/**
 *
 * @export
 * @interface StateDescription
 */
export interface StateDescription {
  /**
   *
   * @type {number}
   * @memberof StateDescription
   */
  minimum?: number;
  /**
   *
   * @type {number}
   * @memberof StateDescription
   */
  maximum?: number;
  /**
   *
   * @type {number}
   * @memberof StateDescription
   */
  step?: number;
  /**
   *
   * @type {string}
   * @memberof StateDescription
   */
  pattern?: string;
  /**
   *
   * @type {boolean}
   * @memberof StateDescription
   */
  readOnly?: boolean;
  /**
   *
   * @type {Array<StateOption>}
   * @memberof StateDescription
   */
  options?: Array<StateOption>;
}

/**
 *
 * @export
 * @interface StateOption
 */
export interface StateOption {
  /**
   *
   * @type {string}
   * @memberof StateOption
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof StateOption
   */
  label?: string;
}

/**
 *
 * @export
 * @interface StrippedThingTypeDTO
 */
export interface StrippedThingTypeDTO {
  /**
   *
   * @type {string}
   * @memberof StrippedThingTypeDTO
   */
  UID?: string;
  /**
   *
   * @type {string}
   * @memberof StrippedThingTypeDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof StrippedThingTypeDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof StrippedThingTypeDTO
   */
  category?: string;
  /**
   *
   * @type {boolean}
   * @memberof StrippedThingTypeDTO
   */
  listed?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof StrippedThingTypeDTO
   */
  supportedBridgeTypeUIDs?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof StrippedThingTypeDTO
   */
  bridge?: boolean;
}

/**
 *
 * @export
 * @interface ThingDTO
 */
export interface ThingDTO {
  /**
   *
   * @type {string}
   * @memberof ThingDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ThingDTO
   */
  bridgeUID?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ThingDTO
   */
  configuration?: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ThingDTO
   */
  properties?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof ThingDTO
   */
  UID?: string;
  /**
   *
   * @type {string}
   * @memberof ThingDTO
   */
  thingTypeUID?: string;
  /**
   *
   * @type {Array<ChannelDTO>}
   * @memberof ThingDTO
   */
  channels?: Array<ChannelDTO>;
  /**
   *
   * @type {string}
   * @memberof ThingDTO
   */
  location?: string;
}

/**
 *
 * @export
 * @interface ThingStatusInfo
 */
export interface ThingStatusInfo {
  /**
   *
   * @type {string}
   * @memberof ThingStatusInfo
   */
  status?: ThingStatusInfo.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof ThingStatusInfo
   */
  statusDetail?: ThingStatusInfo.StatusDetailEnum;
  /**
   *
   * @type {string}
   * @memberof ThingStatusInfo
   */
  description?: string;
}

/**
 * @export
 * @namespace ThingStatusInfo
 */
export namespace ThingStatusInfo {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    UNINITIALIZED = <any>'UNINITIALIZED',
    INITIALIZING = <any>'INITIALIZING',
    UNKNOWN = <any>'UNKNOWN',
    ONLINE = <any>'ONLINE',
    OFFLINE = <any>'OFFLINE',
    REMOVING = <any>'REMOVING',
    REMOVED = <any>'REMOVED'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum StatusDetailEnum {
    NONE = <any>'NONE',
    HANDLERMISSINGERROR = <any>'HANDLER_MISSING_ERROR',
    HANDLERREGISTERINGERROR = <any>'HANDLER_REGISTERING_ERROR',
    HANDLERINITIALIZINGERROR = <any>'HANDLER_INITIALIZING_ERROR',
    HANDLERCONFIGURATIONPENDING = <any>'HANDLER_CONFIGURATION_PENDING',
    CONFIGURATIONPENDING = <any>'CONFIGURATION_PENDING',
    COMMUNICATIONERROR = <any>'COMMUNICATION_ERROR',
    CONFIGURATIONERROR = <any>'CONFIGURATION_ERROR',
    BRIDGEOFFLINE = <any>'BRIDGE_OFFLINE',
    FIRMWAREUPDATING = <any>'FIRMWARE_UPDATING',
    DUTYCYCLE = <any>'DUTY_CYCLE',
    BRIDGEUNINITIALIZED = <any>'BRIDGE_UNINITIALIZED',
    GONE = <any>'GONE',
    DISABLED = <any>'DISABLED'
  }
}

/**
 *
 * @export
 * @interface ThingTypeDTO
 */
export interface ThingTypeDTO {
  /**
   *
   * @type {string}
   * @memberof ThingTypeDTO
   */
  UID?: string;
  /**
   *
   * @type {string}
   * @memberof ThingTypeDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ThingTypeDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ThingTypeDTO
   */
  category?: string;
  /**
   *
   * @type {boolean}
   * @memberof ThingTypeDTO
   */
  listed?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof ThingTypeDTO
   */
  supportedBridgeTypeUIDs?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof ThingTypeDTO
   */
  bridge?: boolean;
  /**
   *
   * @type {Array<ChannelDefinitionDTO>}
   * @memberof ThingTypeDTO
   */
  channels?: Array<ChannelDefinitionDTO>;
  /**
   *
   * @type {Array<ChannelGroupDefinitionDTO>}
   * @memberof ThingTypeDTO
   */
  channelGroups?: Array<ChannelGroupDefinitionDTO>;
  /**
   *
   * @type {Array<ConfigDescriptionParameterDTO>}
   * @memberof ThingTypeDTO
   */
  configParameters?: Array<ConfigDescriptionParameterDTO>;
  /**
   *
   * @type {Array<ConfigDescriptionParameterGroupDTO>}
   * @memberof ThingTypeDTO
   */
  parameterGroups?: Array<ConfigDescriptionParameterGroupDTO>;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ThingTypeDTO
   */
  properties?: { [key: string]: string };
  /**
   *
   * @type {Array<string>}
   * @memberof ThingTypeDTO
   */
  extensibleChannelTypeIds?: Array<string>;
}

/**
 *
 * @export
 * @interface Type
 */
export interface Type {
  /**
   *
   * @type {string}
   * @memberof Type
   */
  typeName?: string;
}

/**
 *
 * @export
 * @interface VoiceDTO
 */
export interface VoiceDTO {
  /**
   *
   * @type {string}
   * @memberof VoiceDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof VoiceDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof VoiceDTO
   */
  locale?: string;
}

/**
 *
 * @export
 * @interface WidgetDTO
 */
export interface WidgetDTO {
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  widgetId?: string;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof WidgetDTO
   */
  visibility?: boolean;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  labelcolor?: string;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  valuecolor?: string;
  /**
   *
   * @type {Array<MappingDTO>}
   * @memberof WidgetDTO
   */
  mappings?: Array<MappingDTO>;
  /**
   *
   * @type {boolean}
   * @memberof WidgetDTO
   */
  switchSupport?: boolean;
  /**
   *
   * @type {number}
   * @memberof WidgetDTO
   */
  sendFrequency?: number;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  separator?: string;
  /**
   *
   * @type {number}
   * @memberof WidgetDTO
   */
  refresh?: number;
  /**
   *
   * @type {number}
   * @memberof WidgetDTO
   */
  height?: number;
  /**
   *
   * @type {number}
   * @memberof WidgetDTO
   */
  minValue?: number;
  /**
   *
   * @type {number}
   * @memberof WidgetDTO
   */
  maxValue?: number;
  /**
   *
   * @type {number}
   * @memberof WidgetDTO
   */
  step?: number;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  encoding?: string;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  service?: string;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  period?: string;
  /**
   *
   * @type {boolean}
   * @memberof WidgetDTO
   */
  legend?: boolean;
  /**
   *
   * @type {string}
   * @memberof WidgetDTO
   */
  state?: string;
  /**
   *
   * @type {EnrichedItemDTO}
   * @memberof WidgetDTO
   */
  item?: EnrichedItemDTO;
  /**
   *
   * @type {PageDTO}
   * @memberof WidgetDTO
   */
  linkedPage?: PageDTO;
  /**
   *
   * @type {Array<WidgetDTO>}
   * @memberof WidgetDTO
   */
  widgets?: Array<WidgetDTO>;
}

/**
 * AudioApi - fetch parameter creator
 * @export
 */
export const AudioApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the default sink if defined or the first available sink.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultSink(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/audio/defaultsink`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get the default source if defined or the first available source.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultSource(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/audio/defaultsource`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get the list of all sinks.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinks(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/audio/sinks`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get the list of all sources.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSources(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/audio/sources`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the default sink if defined or the first available sink.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultSink(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AudioApiFetchParamCreator(configuration).getDefaultSink(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get the default source if defined or the first available source.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultSource(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AudioApiFetchParamCreator(configuration).getDefaultSource(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get the list of all sinks.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinks(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AudioApiFetchParamCreator(configuration).getSinks(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get the list of all sources.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSources(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AudioApiFetchParamCreator(configuration).getSources(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get the default sink if defined or the first available sink.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultSink(acceptLanguage?: string, options?: any) {
      return AudioApiFp(configuration).getDefaultSink(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get the default source if defined or the first available source.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultSource(acceptLanguage?: string, options?: any) {
      return AudioApiFp(configuration).getDefaultSource(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get the list of all sinks.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinks(acceptLanguage?: string, options?: any) {
      return AudioApiFp(configuration).getSinks(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get the list of all sources.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSources(acceptLanguage?: string, options?: any) {
      return AudioApiFp(configuration).getSources(acceptLanguage, options)(fetch, basePath);
    }
  };
};

/**
 * AudioApi - interface
 * @export
 * @interface AudioApi
 */
export interface AudioApiInterface {
  /**
   *
   * @summary Get the default sink if defined or the first available sink.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApiInterface
   */
  getDefaultSink(acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Get the default source if defined or the first available source.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApiInterface
   */
  getDefaultSource(acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Get the list of all sinks.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApiInterface
   */
  getSinks(acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Get the list of all sources.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApiInterface
   */
  getSources(acceptLanguage?: string, options?: any): Promise<{}>;
}

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI implements AudioApiInterface {
  /**
   *
   * @summary Get the default sink if defined or the first available sink.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public getDefaultSink(acceptLanguage?: string, options?: any) {
    return AudioApiFp(this.configuration).getDefaultSink(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the default source if defined or the first available source.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public getDefaultSource(acceptLanguage?: string, options?: any) {
    return AudioApiFp(this.configuration).getDefaultSource(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the list of all sinks.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public getSinks(acceptLanguage?: string, options?: any) {
    return AudioApiFp(this.configuration).getSinks(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the list of all sources.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public getSources(acceptLanguage?: string, options?: any) {
    return AudioApiFp(this.configuration).getSources(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * BindingsApi - fetch parameter creator
 * @export
 */
export const BindingsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all bindings.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/bindings`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get binding configuration for given binding ID.
     * @param {string} bindingId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(bindingId: string, options: any = {}): FetchArgs {
      // verify required parameter 'bindingId' is not null or undefined
      if (bindingId === null || bindingId === undefined) {
        throw new RequiredError(
          'bindingId',
          'Required parameter bindingId was null or undefined when calling getConfiguration.'
        );
      }
      const localVarPath = `/bindings/{bindingId}/config`.replace(
        `{${'bindingId'}}`,
        encodeURIComponent(String(bindingId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Updates a binding configuration for given binding ID and returns the old configuration.
     * @param {string} bindingId service ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(bindingId: string, body?: any, options: any = {}): FetchArgs {
      // verify required parameter 'bindingId' is not null or undefined
      if (bindingId === null || bindingId === undefined) {
        throw new RequiredError(
          'bindingId',
          'Required parameter bindingId was null or undefined when calling updateConfiguration.'
        );
      }
      const localVarPath = `/bindings/{bindingId}/config`.replace(
        `{${'bindingId'}}`,
        encodeURIComponent(String(bindingId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'any' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * BindingsApi - functional programming interface
 * @export
 */
export const BindingsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all bindings.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BindingInfoDTO>> {
      const localVarFetchArgs = BindingsApiFetchParamCreator(configuration).getAll(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get binding configuration for given binding ID.
     * @param {string} bindingId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(
      bindingId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = BindingsApiFetchParamCreator(configuration).getConfiguration(
        bindingId,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Updates a binding configuration for given binding ID and returns the old configuration.
     * @param {string} bindingId service ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(
      bindingId: string,
      body?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = BindingsApiFetchParamCreator(configuration).updateConfiguration(
        bindingId,
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * BindingsApi - factory interface
 * @export
 */
export const BindingsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get all bindings.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options?: any) {
      return BindingsApiFp(configuration).getAll(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get binding configuration for given binding ID.
     * @param {string} bindingId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(bindingId: string, options?: any) {
      return BindingsApiFp(configuration).getConfiguration(bindingId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Updates a binding configuration for given binding ID and returns the old configuration.
     * @param {string} bindingId service ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(bindingId: string, body?: any, options?: any) {
      return BindingsApiFp(configuration).updateConfiguration(
        bindingId,
        body,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * BindingsApi - interface
 * @export
 * @interface BindingsApi
 */
export interface BindingsApiInterface {
  /**
   *
   * @summary Get all bindings.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BindingsApiInterface
   */
  getAll(acceptLanguage?: string, options?: any): Promise<Array<BindingInfoDTO>>;

  /**
   *
   * @summary Get binding configuration for given binding ID.
   * @param {string} bindingId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BindingsApiInterface
   */
  getConfiguration(bindingId: string, options?: any): Promise<string>;

  /**
   *
   * @summary Updates a binding configuration for given binding ID and returns the old configuration.
   * @param {string} bindingId service ID
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BindingsApiInterface
   */
  updateConfiguration(bindingId: string, body?: any, options?: any): Promise<string>;
}

/**
 * BindingsApi - object-oriented interface
 * @export
 * @class BindingsApi
 * @extends {BaseAPI}
 */
export class BindingsApi extends BaseAPI implements BindingsApiInterface {
  /**
   *
   * @summary Get all bindings.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BindingsApi
   */
  public getAll(acceptLanguage?: string, options?: any) {
    return BindingsApiFp(this.configuration).getAll(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get binding configuration for given binding ID.
   * @param {string} bindingId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BindingsApi
   */
  public getConfiguration(bindingId: string, options?: any) {
    return BindingsApiFp(this.configuration).getConfiguration(bindingId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Updates a binding configuration for given binding ID and returns the old configuration.
   * @param {string} bindingId service ID
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BindingsApi
   */
  public updateConfiguration(bindingId: string, body?: any, options?: any) {
    return BindingsApiFp(this.configuration).updateConfiguration(
      bindingId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ChannelTypesApi - fetch parameter creator
 * @export
 */
export const ChannelTypesApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available channel types.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/channel-types`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets channel type by UID.
     * @param {string} channelTypeUID channelTypeUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(channelTypeUID: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'channelTypeUID' is not null or undefined
      if (channelTypeUID === null || channelTypeUID === undefined) {
        throw new RequiredError(
          'channelTypeUID',
          'Required parameter channelTypeUID was null or undefined when calling getByUID.'
        );
      }
      const localVarPath = `/channel-types/{channelTypeUID}`.replace(
        `{${'channelTypeUID'}}`,
        encodeURIComponent(String(channelTypeUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets the item types the given trigger channel type UID can be linked to.
     * @param {string} channelTypeUID channelTypeUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkableItemTypes(channelTypeUID: string, options: any = {}): FetchArgs {
      // verify required parameter 'channelTypeUID' is not null or undefined
      if (channelTypeUID === null || channelTypeUID === undefined) {
        throw new RequiredError(
          'channelTypeUID',
          'Required parameter channelTypeUID was null or undefined when calling getLinkableItemTypes.'
        );
      }
      const localVarPath = `/channel-types/{channelTypeUID}/linkableItemTypes`.replace(
        `{${'channelTypeUID'}}`,
        encodeURIComponent(String(channelTypeUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ChannelTypesApi - functional programming interface
 * @export
 */
export const ChannelTypesApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available channel types.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChannelTypeDTO>> {
      const localVarFetchArgs = ChannelTypesApiFetchParamCreator(configuration).getAll(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets channel type by UID.
     * @param {string} channelTypeUID channelTypeUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(
      channelTypeUID: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChannelTypeDTO> {
      const localVarFetchArgs = ChannelTypesApiFetchParamCreator(configuration).getByUID(
        channelTypeUID,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets the item types the given trigger channel type UID can be linked to.
     * @param {string} channelTypeUID channelTypeUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkableItemTypes(
      channelTypeUID: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ChannelTypesApiFetchParamCreator(
        configuration
      ).getLinkableItemTypes(channelTypeUID, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * ChannelTypesApi - factory interface
 * @export
 */
export const ChannelTypesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets all available channel types.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options?: any) {
      return ChannelTypesApiFp(configuration).getAll(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Gets channel type by UID.
     * @param {string} channelTypeUID channelTypeUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(channelTypeUID: string, acceptLanguage?: string, options?: any) {
      return ChannelTypesApiFp(configuration).getByUID(
        channelTypeUID,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets the item types the given trigger channel type UID can be linked to.
     * @param {string} channelTypeUID channelTypeUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkableItemTypes(channelTypeUID: string, options?: any) {
      return ChannelTypesApiFp(configuration).getLinkableItemTypes(channelTypeUID, options)(
        fetch,
        basePath
      );
    }
  };
};

/**
 * ChannelTypesApi - interface
 * @export
 * @interface ChannelTypesApi
 */
export interface ChannelTypesApiInterface {
  /**
   *
   * @summary Gets all available channel types.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelTypesApiInterface
   */
  getAll(acceptLanguage?: string, options?: any): Promise<Array<ChannelTypeDTO>>;

  /**
   *
   * @summary Gets channel type by UID.
   * @param {string} channelTypeUID channelTypeUID
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelTypesApiInterface
   */
  getByUID(channelTypeUID: string, acceptLanguage?: string, options?: any): Promise<ChannelTypeDTO>;

  /**
   *
   * @summary Gets the item types the given trigger channel type UID can be linked to.
   * @param {string} channelTypeUID channelTypeUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelTypesApiInterface
   */
  getLinkableItemTypes(channelTypeUID: string, options?: any): Promise<Array<string>>;
}

/**
 * ChannelTypesApi - object-oriented interface
 * @export
 * @class ChannelTypesApi
 * @extends {BaseAPI}
 */
export class ChannelTypesApi extends BaseAPI implements ChannelTypesApiInterface {
  /**
   *
   * @summary Gets all available channel types.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelTypesApi
   */
  public getAll(acceptLanguage?: string, options?: any) {
    return ChannelTypesApiFp(this.configuration).getAll(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets channel type by UID.
   * @param {string} channelTypeUID channelTypeUID
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelTypesApi
   */
  public getByUID(channelTypeUID: string, acceptLanguage?: string, options?: any) {
    return ChannelTypesApiFp(this.configuration).getByUID(
      channelTypeUID,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets the item types the given trigger channel type UID can be linked to.
   * @param {string} channelTypeUID channelTypeUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelTypesApi
   */
  public getLinkableItemTypes(channelTypeUID: string, options?: any) {
    return ChannelTypesApiFp(this.configuration).getLinkableItemTypes(channelTypeUID, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * ConfigDescriptionsApi - fetch parameter creator
 * @export
 */
export const ConfigDescriptionsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available config descriptions.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {string} [scheme] scheme filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, scheme?: string, options: any = {}): FetchArgs {
      const localVarPath = `/config-descriptions`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (scheme !== undefined) {
        localVarQueryParameter.scheme = scheme;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets a config description by URI.
     * @param {string} uri uri
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByURI(uri: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'uri' is not null or undefined
      if (uri === null || uri === undefined) {
        throw new RequiredError(
          'uri',
          'Required parameter uri was null or undefined when calling getByURI.'
        );
      }
      const localVarPath = `/config-descriptions/{uri}`.replace(
        `{${'uri'}}`,
        encodeURIComponent(String(uri))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ConfigDescriptionsApi - functional programming interface
 * @export
 */
export const ConfigDescriptionsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available config descriptions.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {string} [scheme] scheme filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      acceptLanguage?: string,
      scheme?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConfigDescriptionDTO>> {
      const localVarFetchArgs = ConfigDescriptionsApiFetchParamCreator(configuration).getAll(
        acceptLanguage,
        scheme,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets a config description by URI.
     * @param {string} uri uri
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByURI(
      uri: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ConfigDescriptionDTO> {
      const localVarFetchArgs = ConfigDescriptionsApiFetchParamCreator(configuration).getByURI(
        uri,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * ConfigDescriptionsApi - factory interface
 * @export
 */
export const ConfigDescriptionsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets all available config descriptions.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {string} [scheme] scheme filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, scheme?: string, options?: any) {
      return ConfigDescriptionsApiFp(configuration).getAll(
        acceptLanguage,
        scheme,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets a config description by URI.
     * @param {string} uri uri
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByURI(uri: string, acceptLanguage?: string, options?: any) {
      return ConfigDescriptionsApiFp(configuration).getByURI(
        uri,
        acceptLanguage,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * ConfigDescriptionsApi - interface
 * @export
 * @interface ConfigDescriptionsApi
 */
export interface ConfigDescriptionsApiInterface {
  /**
   *
   * @summary Gets all available config descriptions.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {string} [scheme] scheme filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigDescriptionsApiInterface
   */
  getAll(
    acceptLanguage?: string,
    scheme?: string,
    options?: any
  ): Promise<Array<ConfigDescriptionDTO>>;

  /**
   *
   * @summary Gets a config description by URI.
   * @param {string} uri uri
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigDescriptionsApiInterface
   */
  getByURI(uri: string, acceptLanguage?: string, options?: any): Promise<ConfigDescriptionDTO>;
}

/**
 * ConfigDescriptionsApi - object-oriented interface
 * @export
 * @class ConfigDescriptionsApi
 * @extends {BaseAPI}
 */
export class ConfigDescriptionsApi extends BaseAPI implements ConfigDescriptionsApiInterface {
  /**
   *
   * @summary Gets all available config descriptions.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {string} [scheme] scheme filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigDescriptionsApi
   */
  public getAll(acceptLanguage?: string, scheme?: string, options?: any) {
    return ConfigDescriptionsApiFp(this.configuration).getAll(
      acceptLanguage,
      scheme,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets a config description by URI.
   * @param {string} uri uri
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigDescriptionsApi
   */
  public getByURI(uri: string, acceptLanguage?: string, options?: any) {
    return ConfigDescriptionsApiFp(this.configuration).getByURI(
      uri,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/iconsets`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoot(options: any = {}): FetchArgs {
      const localVarPath = `/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getAll(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoot(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getRoot(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options?: any) {
      return DefaultApiFp(configuration).getAll(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoot(options?: any) {
      return DefaultApiFp(configuration).getRoot(options)(fetch, basePath);
    }
  };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   *
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getAll(acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getRoot(options?: any): Promise<{}>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   *
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAll(acceptLanguage?: string, options?: any) {
    return DefaultApiFp(this.configuration).getAll(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getRoot(options?: any) {
    return DefaultApiFp(this.configuration).getRoot(options)(this.fetch, this.basePath);
  }
}

/**
 * DiscoveryApi - fetch parameter creator
 * @export
 */
export const DiscoveryApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all bindings that support discovery.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDiscoveryServices(options: any = {}): FetchArgs {
      const localVarPath = `/discovery`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Starts asynchronous discovery process for a binding and returns the timeout in seconds of the discovery operation.
     * @param {string} bindingId bindingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scan(bindingId: string, options: any = {}): FetchArgs {
      // verify required parameter 'bindingId' is not null or undefined
      if (bindingId === null || bindingId === undefined) {
        throw new RequiredError(
          'bindingId',
          'Required parameter bindingId was null or undefined when calling scan.'
        );
      }
      const localVarPath = `/discovery/bindings/{bindingId}/scan`.replace(
        `{${'bindingId'}}`,
        encodeURIComponent(String(bindingId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * DiscoveryApi - functional programming interface
 * @export
 */
export const DiscoveryApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all bindings that support discovery.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDiscoveryServices(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = DiscoveryApiFetchParamCreator(configuration).getDiscoveryServices(
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Starts asynchronous discovery process for a binding and returns the timeout in seconds of the discovery operation.
     * @param {string} bindingId bindingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scan(
      bindingId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs = DiscoveryApiFetchParamCreator(configuration).scan(
        bindingId,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * DiscoveryApi - factory interface
 * @export
 */
export const DiscoveryApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets all bindings that support discovery.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDiscoveryServices(options?: any) {
      return DiscoveryApiFp(configuration).getDiscoveryServices(options)(fetch, basePath);
    },
    /**
     *
     * @summary Starts asynchronous discovery process for a binding and returns the timeout in seconds of the discovery operation.
     * @param {string} bindingId bindingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scan(bindingId: string, options?: any) {
      return DiscoveryApiFp(configuration).scan(bindingId, options)(fetch, basePath);
    }
  };
};

/**
 * DiscoveryApi - interface
 * @export
 * @interface DiscoveryApi
 */
export interface DiscoveryApiInterface {
  /**
   *
   * @summary Gets all bindings that support discovery.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscoveryApiInterface
   */
  getDiscoveryServices(options?: any): Promise<Array<string>>;

  /**
   *
   * @summary Starts asynchronous discovery process for a binding and returns the timeout in seconds of the discovery operation.
   * @param {string} bindingId bindingId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscoveryApiInterface
   */
  scan(bindingId: string, options?: any): Promise<number>;
}

/**
 * DiscoveryApi - object-oriented interface
 * @export
 * @class DiscoveryApi
 * @extends {BaseAPI}
 */
export class DiscoveryApi extends BaseAPI implements DiscoveryApiInterface {
  /**
   *
   * @summary Gets all bindings that support discovery.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscoveryApi
   */
  public getDiscoveryServices(options?: any) {
    return DiscoveryApiFp(this.configuration).getDiscoveryServices(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Starts asynchronous discovery process for a binding and returns the timeout in seconds of the discovery operation.
   * @param {string} bindingId bindingId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscoveryApi
   */
  public scan(bindingId: string, options?: any) {
    return DiscoveryApiFp(this.configuration).scan(bindingId, options)(this.fetch, this.basePath);
  }
}

/**
 * ExtensionsApi - fetch parameter creator
 * @export
 */
export const ExtensionsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get extension with given ID.
     * @param {string} extensionId extension ID
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById(extensionId: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'extensionId' is not null or undefined
      if (extensionId === null || extensionId === undefined) {
        throw new RequiredError(
          'extensionId',
          'Required parameter extensionId was null or undefined when calling getById.'
        );
      }
      const localVarPath = `/extensions/{extensionId}`.replace(
        `{${'extensionId'}}`,
        encodeURIComponent(String(extensionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get all extensions.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExtensions(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/extensions`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get all extension types.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypes(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/extensions/types`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Installs the extension with the given ID.
     * @param {string} extensionId extension ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installExtension(extensionId: string, options: any = {}): FetchArgs {
      // verify required parameter 'extensionId' is not null or undefined
      if (extensionId === null || extensionId === undefined) {
        throw new RequiredError(
          'extensionId',
          'Required parameter extensionId was null or undefined when calling installExtension.'
        );
      }
      const localVarPath = `/extensions/{extensionId}/install`.replace(
        `{${'extensionId'}}`,
        encodeURIComponent(String(extensionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Installs the extension from the given URL.
     * @param {string} _url extension install URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installExtensionByURL(_url: string, options: any = {}): FetchArgs {
      // verify required parameter 'url' is not null or undefined
      if (_url === null || _url === undefined) {
        throw new RequiredError(
          'url',
          'Required parameter url was null or undefined when calling installExtensionByURL.'
        );
      }
      const localVarPath = `/extensions/url/{url}/install`.replace(
        `{${'url'}}`,
        encodeURIComponent(String(_url))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} extensionId extension ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uninstallExtension(extensionId: string, options: any = {}): FetchArgs {
      // verify required parameter 'extensionId' is not null or undefined
      if (extensionId === null || extensionId === undefined) {
        throw new RequiredError(
          'extensionId',
          'Required parameter extensionId was null or undefined when calling uninstallExtension.'
        );
      }
      const localVarPath = `/extensions/{extensionId}/uninstall`.replace(
        `{${'extensionId'}}`,
        encodeURIComponent(String(extensionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get extension with given ID.
     * @param {string} extensionId extension ID
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById(
      extensionId: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ExtensionsApiFetchParamCreator(configuration).getById(
        extensionId,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get all extensions.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExtensions(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ExtensionsApiFetchParamCreator(configuration).getExtensions(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get all extension types.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypes(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ExtensionsApiFetchParamCreator(configuration).getTypes(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Installs the extension with the given ID.
     * @param {string} extensionId extension ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installExtension(
      extensionId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ExtensionsApiFetchParamCreator(configuration).installExtension(
        extensionId,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Installs the extension from the given URL.
     * @param {string} url extension install URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installExtensionByURL(
      url: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ExtensionsApiFetchParamCreator(configuration).installExtensionByURL(
        url,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @param {string} extensionId extension ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uninstallExtension(
      extensionId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ExtensionsApiFetchParamCreator(configuration).uninstallExtension(
        extensionId,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get extension with given ID.
     * @param {string} extensionId extension ID
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById(extensionId: string, acceptLanguage?: string, options?: any) {
      return ExtensionsApiFp(configuration).getById(
        extensionId,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all extensions.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExtensions(acceptLanguage?: string, options?: any) {
      return ExtensionsApiFp(configuration).getExtensions(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get all extension types.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypes(acceptLanguage?: string, options?: any) {
      return ExtensionsApiFp(configuration).getTypes(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Installs the extension with the given ID.
     * @param {string} extensionId extension ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installExtension(extensionId: string, options?: any) {
      return ExtensionsApiFp(configuration).installExtension(extensionId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Installs the extension from the given URL.
     * @param {string} url extension install URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installExtensionByURL(url: string, options?: any) {
      return ExtensionsApiFp(configuration).installExtensionByURL(url, options)(fetch, basePath);
    },
    /**
     *
     * @param {string} extensionId extension ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uninstallExtension(extensionId: string, options?: any) {
      return ExtensionsApiFp(configuration).uninstallExtension(extensionId, options)(
        fetch,
        basePath
      );
    }
  };
};

/**
 * ExtensionsApi - interface
 * @export
 * @interface ExtensionsApi
 */
export interface ExtensionsApiInterface {
  /**
   *
   * @summary Get extension with given ID.
   * @param {string} extensionId extension ID
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApiInterface
   */
  getById(extensionId: string, acceptLanguage?: string, options?: any): Promise<string>;

  /**
   *
   * @summary Get all extensions.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApiInterface
   */
  getExtensions(acceptLanguage?: string, options?: any): Promise<string>;

  /**
   *
   * @summary Get all extension types.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApiInterface
   */
  getTypes(acceptLanguage?: string, options?: any): Promise<string>;

  /**
   *
   * @summary Installs the extension with the given ID.
   * @param {string} extensionId extension ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApiInterface
   */
  installExtension(extensionId: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Installs the extension from the given URL.
   * @param {string} url extension install URL
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApiInterface
   */
  installExtensionByURL(url: string, options?: any): Promise<{}>;

  /**
   *
   * @param {string} extensionId extension ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApiInterface
   */
  uninstallExtension(extensionId: string, options?: any): Promise<{}>;
}

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI implements ExtensionsApiInterface {
  /**
   *
   * @summary Get extension with given ID.
   * @param {string} extensionId extension ID
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public getById(extensionId: string, acceptLanguage?: string, options?: any) {
    return ExtensionsApiFp(this.configuration).getById(
      extensionId,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all extensions.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public getExtensions(acceptLanguage?: string, options?: any) {
    return ExtensionsApiFp(this.configuration).getExtensions(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get all extension types.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public getTypes(acceptLanguage?: string, options?: any) {
    return ExtensionsApiFp(this.configuration).getTypes(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Installs the extension with the given ID.
   * @param {string} extensionId extension ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public installExtension(extensionId: string, options?: any) {
    return ExtensionsApiFp(this.configuration).installExtension(extensionId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Installs the extension from the given URL.
   * @param {string} url extension install URL
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public installExtensionByURL(url: string, options?: any) {
    return ExtensionsApiFp(this.configuration).installExtensionByURL(url, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {string} extensionId extension ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public uninstallExtension(extensionId: string, options?: any) {
    return ExtensionsApiFp(this.configuration).uninstallExtension(extensionId, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * HabpanelApi - fetch parameter creator
 * @export
 */
export const HabpanelApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets the list of widget gallery items.
     * @param {string} galleryName gallery name e.g. &#39;community&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGalleryWidgetList(galleryName: string, options: any = {}): FetchArgs {
      // verify required parameter 'galleryName' is not null or undefined
      if (galleryName === null || galleryName === undefined) {
        throw new RequiredError(
          'galleryName',
          'Required parameter galleryName was null or undefined when calling getGalleryWidgetList.'
        );
      }
      const localVarPath = `/habpanel/gallery/{galleryName}/widgets`.replace(
        `{${'galleryName'}}`,
        encodeURIComponent(String(galleryName))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets the details about a widget gallery item.
     * @param {string} galleryName gallery name e.g. &#39;community&#39;
     * @param {string} id id within the gallery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGalleryWidgetsItem(galleryName: string, id: string, options: any = {}): FetchArgs {
      // verify required parameter 'galleryName' is not null or undefined
      if (galleryName === null || galleryName === undefined) {
        throw new RequiredError(
          'galleryName',
          'Required parameter galleryName was null or undefined when calling getGalleryWidgetsItem.'
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getGalleryWidgetsItem.'
        );
      }
      const localVarPath = `/habpanel/gallery/{galleryName}/widgets/{id}`
        .replace(`{${'galleryName'}}`, encodeURIComponent(String(galleryName)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * HabpanelApi - functional programming interface
 * @export
 */
export const HabpanelApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets the list of widget gallery items.
     * @param {string} galleryName gallery name e.g. &#39;community&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGalleryWidgetList(
      galleryName: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = HabpanelApiFetchParamCreator(configuration).getGalleryWidgetList(
        galleryName,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets the details about a widget gallery item.
     * @param {string} galleryName gallery name e.g. &#39;community&#39;
     * @param {string} id id within the gallery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGalleryWidgetsItem(
      galleryName: string,
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = HabpanelApiFetchParamCreator(configuration).getGalleryWidgetsItem(
        galleryName,
        id,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * HabpanelApi - factory interface
 * @export
 */
export const HabpanelApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets the list of widget gallery items.
     * @param {string} galleryName gallery name e.g. &#39;community&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGalleryWidgetList(galleryName: string, options?: any) {
      return HabpanelApiFp(configuration).getGalleryWidgetList(galleryName, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Gets the details about a widget gallery item.
     * @param {string} galleryName gallery name e.g. &#39;community&#39;
     * @param {string} id id within the gallery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGalleryWidgetsItem(galleryName: string, id: string, options?: any) {
      return HabpanelApiFp(configuration).getGalleryWidgetsItem(
        galleryName,
        id,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * HabpanelApi - interface
 * @export
 * @interface HabpanelApi
 */
export interface HabpanelApiInterface {
  /**
   *
   * @summary Gets the list of widget gallery items.
   * @param {string} galleryName gallery name e.g. &#39;community&#39;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabpanelApiInterface
   */
  getGalleryWidgetList(galleryName: string, options?: any): Promise<string>;

  /**
   *
   * @summary Gets the details about a widget gallery item.
   * @param {string} galleryName gallery name e.g. &#39;community&#39;
   * @param {string} id id within the gallery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabpanelApiInterface
   */
  getGalleryWidgetsItem(galleryName: string, id: string, options?: any): Promise<string>;
}

/**
 * HabpanelApi - object-oriented interface
 * @export
 * @class HabpanelApi
 * @extends {BaseAPI}
 */
export class HabpanelApi extends BaseAPI implements HabpanelApiInterface {
  /**
   *
   * @summary Gets the list of widget gallery items.
   * @param {string} galleryName gallery name e.g. &#39;community&#39;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabpanelApi
   */
  public getGalleryWidgetList(galleryName: string, options?: any) {
    return HabpanelApiFp(this.configuration).getGalleryWidgetList(galleryName, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets the details about a widget gallery item.
   * @param {string} galleryName gallery name e.g. &#39;community&#39;
   * @param {string} id id within the gallery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabpanelApi
   */
  public getGalleryWidgetsItem(galleryName: string, id: string, options?: any) {
    return HabpanelApiFp(this.configuration).getGalleryWidgetsItem(
      galleryName,
      id,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * InboxApi - fetch parameter creator
 * @export
 */
export const InboxApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Removes the discovery result from the inbox.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(thingUID: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling _delete.'
        );
      }
      const localVarPath = `/inbox/{thingUID}`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Approves the discovery result by adding the thing to the registry.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {string} [body] thing label
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approve(
      thingUID: string,
      acceptLanguage?: string,
      body?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling approve.'
        );
      }
      const localVarPath = `/inbox/{thingUID}/approve`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get all discovered things.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options: any = {}): FetchArgs {
      const localVarPath = `/inbox`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Flags a discovery result as ignored for further processing.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ignore(thingUID: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling ignore.'
        );
      }
      const localVarPath = `/inbox/{thingUID}/ignore`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Removes ignore flag from a discovery result.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unignore(thingUID: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling unignore.'
        );
      }
      const localVarPath = `/inbox/{thingUID}/unignore`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * InboxApi - functional programming interface
 * @export
 */
export const InboxApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Removes the discovery result from the inbox.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(
      thingUID: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InboxApiFetchParamCreator(configuration)._delete(thingUID, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Approves the discovery result by adding the thing to the registry.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {string} [body] thing label
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approve(
      thingUID: string,
      acceptLanguage?: string,
      body?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InboxApiFetchParamCreator(configuration).approve(
        thingUID,
        acceptLanguage,
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get all discovered things.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DiscoveryResultDTO> {
      const localVarFetchArgs = InboxApiFetchParamCreator(configuration).getAll(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Flags a discovery result as ignored for further processing.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ignore(
      thingUID: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InboxApiFetchParamCreator(configuration).ignore(thingUID, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Removes ignore flag from a discovery result.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unignore(
      thingUID: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InboxApiFetchParamCreator(configuration).unignore(
        thingUID,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * InboxApi - factory interface
 * @export
 */
export const InboxApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Removes the discovery result from the inbox.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(thingUID: string, options?: any) {
      return InboxApiFp(configuration)._delete(thingUID, options)(fetch, basePath);
    },
    /**
     *
     * @summary Approves the discovery result by adding the thing to the registry.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {string} [body] thing label
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approve(thingUID: string, acceptLanguage?: string, body?: string, options?: any) {
      return InboxApiFp(configuration).approve(
        thingUID,
        acceptLanguage,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all discovered things.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options?: any) {
      return InboxApiFp(configuration).getAll(options)(fetch, basePath);
    },
    /**
     *
     * @summary Flags a discovery result as ignored for further processing.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ignore(thingUID: string, options?: any) {
      return InboxApiFp(configuration).ignore(thingUID, options)(fetch, basePath);
    },
    /**
     *
     * @summary Removes ignore flag from a discovery result.
     * @param {string} thingUID thingUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unignore(thingUID: string, options?: any) {
      return InboxApiFp(configuration).unignore(thingUID, options)(fetch, basePath);
    }
  };
};

/**
 * InboxApi - interface
 * @export
 * @interface InboxApi
 */
export interface InboxApiInterface {
  /**
   *
   * @summary Removes the discovery result from the inbox.
   * @param {string} thingUID thingUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApiInterface
   */
  _delete(thingUID: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Approves the discovery result by adding the thing to the registry.
   * @param {string} thingUID thingUID
   * @param {string} [acceptLanguage] language
   * @param {string} [body] thing label
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApiInterface
   */
  approve(thingUID: string, acceptLanguage?: string, body?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Get all discovered things.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApiInterface
   */
  getAll(options?: any): Promise<DiscoveryResultDTO>;

  /**
   *
   * @summary Flags a discovery result as ignored for further processing.
   * @param {string} thingUID thingUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApiInterface
   */
  ignore(thingUID: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Removes ignore flag from a discovery result.
   * @param {string} thingUID thingUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApiInterface
   */
  unignore(thingUID: string, options?: any): Promise<{}>;
}

/**
 * InboxApi - object-oriented interface
 * @export
 * @class InboxApi
 * @extends {BaseAPI}
 */
export class InboxApi extends BaseAPI implements InboxApiInterface {
  /**
   *
   * @summary Removes the discovery result from the inbox.
   * @param {string} thingUID thingUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  public _delete(thingUID: string, options?: any) {
    return InboxApiFp(this.configuration)._delete(thingUID, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Approves the discovery result by adding the thing to the registry.
   * @param {string} thingUID thingUID
   * @param {string} [acceptLanguage] language
   * @param {string} [body] thing label
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  public approve(thingUID: string, acceptLanguage?: string, body?: string, options?: any) {
    return InboxApiFp(this.configuration).approve(
      thingUID,
      acceptLanguage,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all discovered things.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  public getAll(options?: any) {
    return InboxApiFp(this.configuration).getAll(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Flags a discovery result as ignored for further processing.
   * @param {string} thingUID thingUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  public ignore(thingUID: string, options?: any) {
    return InboxApiFp(this.configuration).ignore(thingUID, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Removes ignore flag from a discovery result.
   * @param {string} thingUID thingUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  public unignore(thingUID: string, options?: any) {
    return InboxApiFp(this.configuration).unignore(thingUID, options)(this.fetch, this.basePath);
  }
}

/**
 * ItemsApi - fetch parameter creator
 * @export
 */
export const ItemsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Adds a new member to a group item.
     * @param {string} itemName item name
     * @param {string} memberItemName member item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMember(itemName: string, memberItemName: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemName' is not null or undefined
      if (itemName === null || itemName === undefined) {
        throw new RequiredError(
          'itemName',
          'Required parameter itemName was null or undefined when calling addMember.'
        );
      }
      // verify required parameter 'memberItemName' is not null or undefined
      if (memberItemName === null || memberItemName === undefined) {
        throw new RequiredError(
          'memberItemName',
          'Required parameter memberItemName was null or undefined when calling addMember.'
        );
      }
      const localVarPath = `/items/{itemName}/members/{memberItemName}`
        .replace(`{${'itemName'}}`, encodeURIComponent(String(itemName)))
        .replace(`{${'memberItemName'}}`, encodeURIComponent(String(memberItemName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Adds metadata to an item.
     * @param {string} itemname item name
     * @param {string} namespace namespace
     * @param {MetadataDTO} body metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMetadata(
      itemname: string,
      namespace: string,
      body: MetadataDTO,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling addMetadata.'
        );
      }
      // verify required parameter 'namespace' is not null or undefined
      if (namespace === null || namespace === undefined) {
        throw new RequiredError(
          'namespace',
          'Required parameter namespace was null or undefined when calling addMetadata.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling addMetadata.'
        );
      }
      const localVarPath = `/items/{itemname}/metadata/{namespace}`
        .replace(`{${'itemname'}}`, encodeURIComponent(String(itemname)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'MetadataDTO' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Adds a tag to an item.
     * @param {string} itemname item name
     * @param {string} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTag(itemname: string, tag: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling addTag.'
        );
      }
      // verify required parameter 'tag' is not null or undefined
      if (tag === null || tag === undefined) {
        throw new RequiredError(
          'tag',
          'Required parameter tag was null or undefined when calling addTag.'
        );
      }
      const localVarPath = `/items/{itemname}/tags/{tag}`
        .replace(`{${'itemname'}}`, encodeURIComponent(String(itemname)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Adds a new item to the registry or updates the existing item.
     * @param {string} itemname item name
     * @param {GroupItemDTO} body item data
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateItem(
      itemname: string,
      body: GroupItemDTO,
      acceptLanguage?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling createOrUpdateItem.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createOrUpdateItem.'
        );
      }
      const localVarPath = `/items/{itemname}`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'GroupItemDTO' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Adds a list of items to the registry or updates the existing items.
     * @param {Array<GroupItemDTO>} body array of item data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateItems(body: Array<GroupItemDTO>, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createOrUpdateItems.'
        );
      }
      const localVarPath = `/items`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'Array&lt;GroupItemDTO&gt;' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets a single item.
     * @param {string} itemname item name
     * @param {string} [acceptLanguage] language
     * @param {string} [metadata] metadata selector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItemData(
      itemname: string,
      acceptLanguage?: string,
      metadata?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling getItemData.'
        );
      }
      const localVarPath = `/items/{itemname}`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (metadata !== undefined) {
        localVarQueryParameter.metadata = metadata;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get all available items.
     * @param {string} [acceptLanguage] language
     * @param {string} [type] item type filter
     * @param {string} [tags] item tag filter
     * @param {string} [metadata] metadata selector
     * @param {boolean} [recursive] get member items recursively
     * @param {string} [fields] limit output to the given fields (comma separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(
      acceptLanguage?: string,
      type?: string,
      tags?: string,
      metadata?: string,
      recursive?: boolean,
      fields?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/items`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type !== undefined) {
        localVarQueryParameter.type = type;
      }

      if (tags !== undefined) {
        localVarQueryParameter.tags = tags;
      }

      if (metadata !== undefined) {
        localVarQueryParameter.metadata = metadata;
      }

      if (recursive !== undefined) {
        localVarQueryParameter.recursive = recursive;
      }

      if (fields !== undefined) {
        localVarQueryParameter.fields = fields;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets the state of an item.
     * @param {string} itemname item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlainItemState(itemname: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling getPlainItemState.'
        );
      }
      const localVarPath = `/items/{itemname}/state`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Sends a command to an item.
     * @param {string} itemname item name
     * @param {string} body valid item command (e.g. ON, OFF, UP, DOWN, REFRESH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postItemCommand(itemname: string, body: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling postItemCommand.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling postItemCommand.'
        );
      }
      const localVarPath = `/items/{itemname}`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Updates the state of an item.
     * @param {string} itemname item name
     * @param {string} body valid item state (e.g. ON, OFF)
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putItemState(
      itemname: string,
      body: string,
      acceptLanguage?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling putItemState.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling putItemState.'
        );
      }
      const localVarPath = `/items/{itemname}/state`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Removes an item from the registry.
     * @param {string} itemname item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeItem(itemname: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling removeItem.'
        );
      }
      const localVarPath = `/items/{itemname}`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Removes an existing member from a group item.
     * @param {string} itemName item name
     * @param {string} memberItemName member item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMember(itemName: string, memberItemName: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemName' is not null or undefined
      if (itemName === null || itemName === undefined) {
        throw new RequiredError(
          'itemName',
          'Required parameter itemName was null or undefined when calling removeMember.'
        );
      }
      // verify required parameter 'memberItemName' is not null or undefined
      if (memberItemName === null || memberItemName === undefined) {
        throw new RequiredError(
          'memberItemName',
          'Required parameter memberItemName was null or undefined when calling removeMember.'
        );
      }
      const localVarPath = `/items/{itemName}/members/{memberItemName}`
        .replace(`{${'itemName'}}`, encodeURIComponent(String(itemName)))
        .replace(`{${'memberItemName'}}`, encodeURIComponent(String(memberItemName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Removes metadata from an item.
     * @param {string} itemname item name
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMetadata(itemname: string, namespace: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling removeMetadata.'
        );
      }
      // verify required parameter 'namespace' is not null or undefined
      if (namespace === null || namespace === undefined) {
        throw new RequiredError(
          'namespace',
          'Required parameter namespace was null or undefined when calling removeMetadata.'
        );
      }
      const localVarPath = `/items/{itemname}/metadata/{namespace}`
        .replace(`{${'itemname'}}`, encodeURIComponent(String(itemname)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Removes a tag from an item.
     * @param {string} itemname item name
     * @param {string} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeTag(itemname: string, tag: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling removeTag.'
        );
      }
      // verify required parameter 'tag' is not null or undefined
      if (tag === null || tag === undefined) {
        throw new RequiredError(
          'tag',
          'Required parameter tag was null or undefined when calling removeTag.'
        );
      }
      const localVarPath = `/items/{itemname}/tags/{tag}`
        .replace(`{${'itemname'}}`, encodeURIComponent(String(itemname)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Adds a new member to a group item.
     * @param {string} itemName item name
     * @param {string} memberItemName member item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMember(
      itemName: string,
      memberItemName: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).addMember(
        itemName,
        memberItemName,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Adds metadata to an item.
     * @param {string} itemname item name
     * @param {string} namespace namespace
     * @param {MetadataDTO} body metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMetadata(
      itemname: string,
      namespace: string,
      body: MetadataDTO,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).addMetadata(
        itemname,
        namespace,
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Adds a tag to an item.
     * @param {string} itemname item name
     * @param {string} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTag(
      itemname: string,
      tag: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).addTag(
        itemname,
        tag,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Adds a new item to the registry or updates the existing item.
     * @param {string} itemname item name
     * @param {GroupItemDTO} body item data
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateItem(
      itemname: string,
      body: GroupItemDTO,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).createOrUpdateItem(
        itemname,
        body,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Adds a list of items to the registry or updates the existing items.
     * @param {Array<GroupItemDTO>} body array of item data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateItems(
      body: Array<GroupItemDTO>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).createOrUpdateItems(
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets a single item.
     * @param {string} itemname item name
     * @param {string} [acceptLanguage] language
     * @param {string} [metadata] metadata selector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItemData(
      itemname: string,
      acceptLanguage?: string,
      metadata?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<EnrichedItemDTO> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).getItemData(
        itemname,
        acceptLanguage,
        metadata,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get all available items.
     * @param {string} [acceptLanguage] language
     * @param {string} [type] item type filter
     * @param {string} [tags] item tag filter
     * @param {string} [metadata] metadata selector
     * @param {boolean} [recursive] get member items recursively
     * @param {string} [fields] limit output to the given fields (comma separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(
      acceptLanguage?: string,
      type?: string,
      tags?: string,
      metadata?: string,
      recursive?: boolean,
      fields?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EnrichedItemDTO>> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).getItems(
        acceptLanguage,
        type,
        tags,
        metadata,
        recursive,
        fields,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets the state of an item.
     * @param {string} itemname item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlainItemState(
      itemname: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).getPlainItemState(
        itemname,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Sends a command to an item.
     * @param {string} itemname item name
     * @param {string} body valid item command (e.g. ON, OFF, UP, DOWN, REFRESH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postItemCommand(
      itemname: string,
      body: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).postItemCommand(
        itemname,
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Updates the state of an item.
     * @param {string} itemname item name
     * @param {string} body valid item state (e.g. ON, OFF)
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putItemState(
      itemname: string,
      body: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).putItemState(
        itemname,
        body,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Removes an item from the registry.
     * @param {string} itemname item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeItem(
      itemname: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).removeItem(
        itemname,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Removes an existing member from a group item.
     * @param {string} itemName item name
     * @param {string} memberItemName member item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMember(
      itemName: string,
      memberItemName: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).removeMember(
        itemName,
        memberItemName,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Removes metadata from an item.
     * @param {string} itemname item name
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMetadata(
      itemname: string,
      namespace: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).removeMetadata(
        itemname,
        namespace,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Removes a tag from an item.
     * @param {string} itemname item name
     * @param {string} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeTag(
      itemname: string,
      tag: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).removeTag(
        itemname,
        tag,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Adds a new member to a group item.
     * @param {string} itemName item name
     * @param {string} memberItemName member item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMember(itemName: string, memberItemName: string, options?: any) {
      return ItemsApiFp(configuration).addMember(
        itemName,
        memberItemName,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Adds metadata to an item.
     * @param {string} itemname item name
     * @param {string} namespace namespace
     * @param {MetadataDTO} body metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMetadata(itemname: string, namespace: string, body: MetadataDTO, options?: any) {
      return ItemsApiFp(configuration).addMetadata(
        itemname,
        namespace,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Adds a tag to an item.
     * @param {string} itemname item name
     * @param {string} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTag(itemname: string, tag: string, options?: any) {
      return ItemsApiFp(configuration).addTag(itemname, tag, options)(fetch, basePath);
    },
    /**
     *
     * @summary Adds a new item to the registry or updates the existing item.
     * @param {string} itemname item name
     * @param {GroupItemDTO} body item data
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateItem(
      itemname: string,
      body: GroupItemDTO,
      acceptLanguage?: string,
      options?: any
    ) {
      return ItemsApiFp(configuration).createOrUpdateItem(
        itemname,
        body,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Adds a list of items to the registry or updates the existing items.
     * @param {Array<GroupItemDTO>} body array of item data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateItems(body: Array<GroupItemDTO>, options?: any) {
      return ItemsApiFp(configuration).createOrUpdateItems(body, options)(fetch, basePath);
    },
    /**
     *
     * @summary Gets a single item.
     * @param {string} itemname item name
     * @param {string} [acceptLanguage] language
     * @param {string} [metadata] metadata selector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItemData(itemname: string, acceptLanguage?: string, metadata?: string, options?: any) {
      return ItemsApiFp(configuration).getItemData(
        itemname,
        acceptLanguage,
        metadata,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all available items.
     * @param {string} [acceptLanguage] language
     * @param {string} [type] item type filter
     * @param {string} [tags] item tag filter
     * @param {string} [metadata] metadata selector
     * @param {boolean} [recursive] get member items recursively
     * @param {string} [fields] limit output to the given fields (comma separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(
      acceptLanguage?: string,
      type?: string,
      tags?: string,
      metadata?: string,
      recursive?: boolean,
      fields?: string,
      options?: any
    ) {
      return ItemsApiFp(configuration).getItems(
        acceptLanguage,
        type,
        tags,
        metadata,
        recursive,
        fields,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets the state of an item.
     * @param {string} itemname item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlainItemState(itemname: string, options?: any) {
      return ItemsApiFp(configuration).getPlainItemState(itemname, options)(fetch, basePath);
    },
    /**
     *
     * @summary Sends a command to an item.
     * @param {string} itemname item name
     * @param {string} body valid item command (e.g. ON, OFF, UP, DOWN, REFRESH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postItemCommand(itemname: string, body: string, options?: any) {
      return ItemsApiFp(configuration).postItemCommand(itemname, body, options)(fetch, basePath);
    },
    /**
     *
     * @summary Updates the state of an item.
     * @param {string} itemname item name
     * @param {string} body valid item state (e.g. ON, OFF)
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putItemState(itemname: string, body: string, acceptLanguage?: string, options?: any) {
      return ItemsApiFp(configuration).putItemState(
        itemname,
        body,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Removes an item from the registry.
     * @param {string} itemname item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeItem(itemname: string, options?: any) {
      return ItemsApiFp(configuration).removeItem(itemname, options)(fetch, basePath);
    },
    /**
     *
     * @summary Removes an existing member from a group item.
     * @param {string} itemName item name
     * @param {string} memberItemName member item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMember(itemName: string, memberItemName: string, options?: any) {
      return ItemsApiFp(configuration).removeMember(
        itemName,
        memberItemName,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Removes metadata from an item.
     * @param {string} itemname item name
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMetadata(itemname: string, namespace: string, options?: any) {
      return ItemsApiFp(configuration).removeMetadata(
        itemname,
        namespace,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Removes a tag from an item.
     * @param {string} itemname item name
     * @param {string} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeTag(itemname: string, tag: string, options?: any) {
      return ItemsApiFp(configuration).removeTag(itemname, tag, options)(fetch, basePath);
    }
  };
};

/**
 * ItemsApi - interface
 * @export
 * @interface ItemsApi
 */
export interface ItemsApiInterface {
  /**
   *
   * @summary Adds a new member to a group item.
   * @param {string} itemName item name
   * @param {string} memberItemName member item name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  addMember(itemName: string, memberItemName: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Adds metadata to an item.
   * @param {string} itemname item name
   * @param {string} namespace namespace
   * @param {MetadataDTO} body metadata
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  addMetadata(itemname: string, namespace: string, body: MetadataDTO, options?: any): Promise<{}>;

  /**
   *
   * @summary Adds a tag to an item.
   * @param {string} itemname item name
   * @param {string} tag tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  addTag(itemname: string, tag: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Adds a new item to the registry or updates the existing item.
   * @param {string} itemname item name
   * @param {GroupItemDTO} body item data
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  createOrUpdateItem(
    itemname: string,
    body: GroupItemDTO,
    acceptLanguage?: string,
    options?: any
  ): Promise<string>;

  /**
   *
   * @summary Adds a list of items to the registry or updates the existing items.
   * @param {Array<GroupItemDTO>} body array of item data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  createOrUpdateItems(body: Array<GroupItemDTO>, options?: any): Promise<string>;

  /**
   *
   * @summary Gets a single item.
   * @param {string} itemname item name
   * @param {string} [acceptLanguage] language
   * @param {string} [metadata] metadata selector
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  getItemData(
    itemname: string,
    acceptLanguage?: string,
    metadata?: string,
    options?: any
  ): Promise<EnrichedItemDTO>;

  /**
   *
   * @summary Get all available items.
   * @param {string} [acceptLanguage] language
   * @param {string} [type] item type filter
   * @param {string} [tags] item tag filter
   * @param {string} [metadata] metadata selector
   * @param {boolean} [recursive] get member items recursively
   * @param {string} [fields] limit output to the given fields (comma separated)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  getItems(
    acceptLanguage?: string,
    type?: string,
    tags?: string,
    metadata?: string,
    recursive?: boolean,
    fields?: string,
    options?: any
  ): Promise<Array<EnrichedItemDTO>>;

  /**
   *
   * @summary Gets the state of an item.
   * @param {string} itemname item name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  getPlainItemState(itemname: string, options?: any): Promise<string>;

  /**
   *
   * @summary Sends a command to an item.
   * @param {string} itemname item name
   * @param {string} body valid item command (e.g. ON, OFF, UP, DOWN, REFRESH)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  postItemCommand(itemname: string, body: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Updates the state of an item.
   * @param {string} itemname item name
   * @param {string} body valid item state (e.g. ON, OFF)
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  putItemState(itemname: string, body: string, acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Removes an item from the registry.
   * @param {string} itemname item name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  removeItem(itemname: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Removes an existing member from a group item.
   * @param {string} itemName item name
   * @param {string} memberItemName member item name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  removeMember(itemName: string, memberItemName: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Removes metadata from an item.
   * @param {string} itemname item name
   * @param {string} namespace namespace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  removeMetadata(itemname: string, namespace: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Removes a tag from an item.
   * @param {string} itemname item name
   * @param {string} tag tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApiInterface
   */
  removeTag(itemname: string, tag: string, options?: any): Promise<{}>;
}

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI implements ItemsApiInterface {
  /**
   *
   * @summary Adds a new member to a group item.
   * @param {string} itemName item name
   * @param {string} memberItemName member item name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public addMember(itemName: string, memberItemName: string, options?: any) {
    return ItemsApiFp(this.configuration).addMember(
      itemName,
      memberItemName,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Adds metadata to an item.
   * @param {string} itemname item name
   * @param {string} namespace namespace
   * @param {MetadataDTO} body metadata
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public addMetadata(itemname: string, namespace: string, body: MetadataDTO, options?: any) {
    return ItemsApiFp(this.configuration).addMetadata(
      itemname,
      namespace,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Adds a tag to an item.
   * @param {string} itemname item name
   * @param {string} tag tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public addTag(itemname: string, tag: string, options?: any) {
    return ItemsApiFp(this.configuration).addTag(itemname, tag, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Adds a new item to the registry or updates the existing item.
   * @param {string} itemname item name
   * @param {GroupItemDTO} body item data
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public createOrUpdateItem(
    itemname: string,
    body: GroupItemDTO,
    acceptLanguage?: string,
    options?: any
  ) {
    return ItemsApiFp(this.configuration).createOrUpdateItem(
      itemname,
      body,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Adds a list of items to the registry or updates the existing items.
   * @param {Array<GroupItemDTO>} body array of item data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public createOrUpdateItems(body: Array<GroupItemDTO>, options?: any) {
    return ItemsApiFp(this.configuration).createOrUpdateItems(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets a single item.
   * @param {string} itemname item name
   * @param {string} [acceptLanguage] language
   * @param {string} [metadata] metadata selector
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public getItemData(itemname: string, acceptLanguage?: string, metadata?: string, options?: any) {
    return ItemsApiFp(this.configuration).getItemData(
      itemname,
      acceptLanguage,
      metadata,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all available items.
   * @param {string} [acceptLanguage] language
   * @param {string} [type] item type filter
   * @param {string} [tags] item tag filter
   * @param {string} [metadata] metadata selector
   * @param {boolean} [recursive] get member items recursively
   * @param {string} [fields] limit output to the given fields (comma separated)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public getItems(
    acceptLanguage?: string,
    type?: string,
    tags?: string,
    metadata?: string,
    recursive?: boolean,
    fields?: string,
    options?: any
  ) {
    return ItemsApiFp(this.configuration).getItems(
      acceptLanguage,
      type,
      tags,
      metadata,
      recursive,
      fields,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets the state of an item.
   * @param {string} itemname item name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public getPlainItemState(itemname: string, options?: any) {
    return ItemsApiFp(this.configuration).getPlainItemState(itemname, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Sends a command to an item.
   * @param {string} itemname item name
   * @param {string} body valid item command (e.g. ON, OFF, UP, DOWN, REFRESH)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public postItemCommand(itemname: string, body: string, options?: any) {
    return ItemsApiFp(this.configuration).postItemCommand(
      itemname,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Updates the state of an item.
   * @param {string} itemname item name
   * @param {string} body valid item state (e.g. ON, OFF)
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public putItemState(itemname: string, body: string, acceptLanguage?: string, options?: any) {
    return ItemsApiFp(this.configuration).putItemState(
      itemname,
      body,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Removes an item from the registry.
   * @param {string} itemname item name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public removeItem(itemname: string, options?: any) {
    return ItemsApiFp(this.configuration).removeItem(itemname, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Removes an existing member from a group item.
   * @param {string} itemName item name
   * @param {string} memberItemName member item name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public removeMember(itemName: string, memberItemName: string, options?: any) {
    return ItemsApiFp(this.configuration).removeMember(
      itemName,
      memberItemName,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Removes metadata from an item.
   * @param {string} itemname item name
   * @param {string} namespace namespace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public removeMetadata(itemname: string, namespace: string, options?: any) {
    return ItemsApiFp(this.configuration).removeMetadata(
      itemname,
      namespace,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Removes a tag from an item.
   * @param {string} itemname item name
   * @param {string} tag tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public removeTag(itemname: string, tag: string, options?: any) {
    return ItemsApiFp(this.configuration).removeTag(
      itemname,
      tag,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * LinksApi - fetch parameter creator
 * @export
 */
export const LinksApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options: any = {}): FetchArgs {
      const localVarPath = `/links`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Retrieves links.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLink(itemName: string, channelUID: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemName' is not null or undefined
      if (itemName === null || itemName === undefined) {
        throw new RequiredError(
          'itemName',
          'Required parameter itemName was null or undefined when calling getLink.'
        );
      }
      // verify required parameter 'channelUID' is not null or undefined
      if (channelUID === null || channelUID === undefined) {
        throw new RequiredError(
          'channelUID',
          'Required parameter channelUID was null or undefined when calling getLink.'
        );
      }
      const localVarPath = `/links/{itemName}/{channelUID}`
        .replace(`{${'itemName'}}`, encodeURIComponent(String(itemName)))
        .replace(`{${'channelUID'}}`, encodeURIComponent(String(channelUID)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Tells whether automatic link mode is active or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAutomatic(options: any = {}): FetchArgs {
      const localVarPath = `/links/auto`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Links item to a channel.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {ItemChannelLinkDTO} [body] link data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    link(
      itemName: string,
      channelUID: string,
      body?: ItemChannelLinkDTO,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'itemName' is not null or undefined
      if (itemName === null || itemName === undefined) {
        throw new RequiredError(
          'itemName',
          'Required parameter itemName was null or undefined when calling link.'
        );
      }
      // verify required parameter 'channelUID' is not null or undefined
      if (channelUID === null || channelUID === undefined) {
        throw new RequiredError(
          'channelUID',
          'Required parameter channelUID was null or undefined when calling link.'
        );
      }
      const localVarPath = `/links/{itemName}/{channelUID}`
        .replace(`{${'itemName'}}`, encodeURIComponent(String(itemName)))
        .replace(`{${'channelUID'}}`, encodeURIComponent(String(channelUID)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'ItemChannelLinkDTO' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Unlinks item from a channel.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlink(itemName: string, channelUID: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemName' is not null or undefined
      if (itemName === null || itemName === undefined) {
        throw new RequiredError(
          'itemName',
          'Required parameter itemName was null or undefined when calling unlink.'
        );
      }
      // verify required parameter 'channelUID' is not null or undefined
      if (channelUID === null || channelUID === undefined) {
        throw new RequiredError(
          'channelUID',
          'Required parameter channelUID was null or undefined when calling unlink.'
        );
      }
      const localVarPath = `/links/{itemName}/{channelUID}`
        .replace(`{${'itemName'}}`, encodeURIComponent(String(itemName)))
        .replace(`{${'channelUID'}}`, encodeURIComponent(String(channelUID)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * LinksApi - functional programming interface
 * @export
 */
export const LinksApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemChannelLinkDTO> {
      const localVarFetchArgs = LinksApiFetchParamCreator(configuration).getAll(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Retrieves links.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLink(
      itemName: string,
      channelUID: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = LinksApiFetchParamCreator(configuration).getLink(
        itemName,
        channelUID,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Tells whether automatic link mode is active or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAutomatic(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = LinksApiFetchParamCreator(configuration).isAutomatic(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Links item to a channel.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {ItemChannelLinkDTO} [body] link data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    link(
      itemName: string,
      channelUID: string,
      body?: ItemChannelLinkDTO,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = LinksApiFetchParamCreator(configuration).link(
        itemName,
        channelUID,
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Unlinks item from a channel.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlink(
      itemName: string,
      channelUID: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = LinksApiFetchParamCreator(configuration).unlink(
        itemName,
        channelUID,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * LinksApi - factory interface
 * @export
 */
export const LinksApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets all available links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options?: any) {
      return LinksApiFp(configuration).getAll(options)(fetch, basePath);
    },
    /**
     *
     * @summary Retrieves links.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLink(itemName: string, channelUID: string, options?: any) {
      return LinksApiFp(configuration).getLink(itemName, channelUID, options)(fetch, basePath);
    },
    /**
     *
     * @summary Tells whether automatic link mode is active or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAutomatic(options?: any) {
      return LinksApiFp(configuration).isAutomatic(options)(fetch, basePath);
    },
    /**
     *
     * @summary Links item to a channel.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {ItemChannelLinkDTO} [body] link data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    link(itemName: string, channelUID: string, body?: ItemChannelLinkDTO, options?: any) {
      return LinksApiFp(configuration).link(itemName, channelUID, body, options)(fetch, basePath);
    },
    /**
     *
     * @summary Unlinks item from a channel.
     * @param {string} itemName itemName
     * @param {string} channelUID channelUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlink(itemName: string, channelUID: string, options?: any) {
      return LinksApiFp(configuration).unlink(itemName, channelUID, options)(fetch, basePath);
    }
  };
};

/**
 * LinksApi - interface
 * @export
 * @interface LinksApi
 */
export interface LinksApiInterface {
  /**
   *
   * @summary Gets all available links.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApiInterface
   */
  getAll(options?: any): Promise<ItemChannelLinkDTO>;

  /**
   *
   * @summary Retrieves links.
   * @param {string} itemName itemName
   * @param {string} channelUID channelUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApiInterface
   */
  getLink(itemName: string, channelUID: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Tells whether automatic link mode is active or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApiInterface
   */
  isAutomatic(options?: any): Promise<boolean>;

  /**
   *
   * @summary Links item to a channel.
   * @param {string} itemName itemName
   * @param {string} channelUID channelUID
   * @param {ItemChannelLinkDTO} [body] link data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApiInterface
   */
  link(itemName: string, channelUID: string, body?: ItemChannelLinkDTO, options?: any): Promise<{}>;

  /**
   *
   * @summary Unlinks item from a channel.
   * @param {string} itemName itemName
   * @param {string} channelUID channelUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApiInterface
   */
  unlink(itemName: string, channelUID: string, options?: any): Promise<{}>;
}

/**
 * LinksApi - object-oriented interface
 * @export
 * @class LinksApi
 * @extends {BaseAPI}
 */
export class LinksApi extends BaseAPI implements LinksApiInterface {
  /**
   *
   * @summary Gets all available links.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public getAll(options?: any) {
    return LinksApiFp(this.configuration).getAll(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Retrieves links.
   * @param {string} itemName itemName
   * @param {string} channelUID channelUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public getLink(itemName: string, channelUID: string, options?: any) {
    return LinksApiFp(this.configuration).getLink(
      itemName,
      channelUID,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Tells whether automatic link mode is active or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public isAutomatic(options?: any) {
    return LinksApiFp(this.configuration).isAutomatic(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Links item to a channel.
   * @param {string} itemName itemName
   * @param {string} channelUID channelUID
   * @param {ItemChannelLinkDTO} [body] link data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public link(itemName: string, channelUID: string, body?: ItemChannelLinkDTO, options?: any) {
    return LinksApiFp(this.configuration).link(
      itemName,
      channelUID,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Unlinks item from a channel.
   * @param {string} itemName itemName
   * @param {string} channelUID channelUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public unlink(itemName: string, channelUID: string, options?: any) {
    return LinksApiFp(this.configuration).unlink(
      itemName,
      channelUID,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * PersistenceApi - fetch parameter creator
 * @export
 */
export const PersistenceApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete item data from a specific persistence service.
     * @param {string} serviceId Id of the persistence service.
     * @param {string} itemname The item name.
     * @param {string} starttime Start time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} endtime End time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpDeletePersistenceServiceItem(
      serviceId: string,
      itemname: string,
      starttime: string,
      endtime: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'serviceId' is not null or undefined
      if (serviceId === null || serviceId === undefined) {
        throw new RequiredError(
          'serviceId',
          'Required parameter serviceId was null or undefined when calling httpDeletePersistenceServiceItem.'
        );
      }
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling httpDeletePersistenceServiceItem.'
        );
      }
      // verify required parameter 'starttime' is not null or undefined
      if (starttime === null || starttime === undefined) {
        throw new RequiredError(
          'starttime',
          'Required parameter starttime was null or undefined when calling httpDeletePersistenceServiceItem.'
        );
      }
      // verify required parameter 'endtime' is not null or undefined
      if (endtime === null || endtime === undefined) {
        throw new RequiredError(
          'endtime',
          'Required parameter endtime was null or undefined when calling httpDeletePersistenceServiceItem.'
        );
      }
      const localVarPath = `/persistence/items/{itemname}`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serviceId !== undefined) {
        localVarQueryParameter.serviceId = serviceId;
      }

      if (starttime !== undefined) {
        localVarQueryParameter.starttime = starttime;
      }

      if (endtime !== undefined) {
        localVarQueryParameter.endtime = endtime;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets item persistence data from the persistence service.
     * @param {string} itemname The item name
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {string} [starttime] Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} [endtime] End time of the data to return. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {number} [page] Page number of data to return. This parameter will enable paging.
     * @param {number} [pagelength] The length of each page.
     * @param {boolean} [boundary] Gets one value before and after the requested period.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceItemData(
      itemname: string,
      serviceId?: string,
      starttime?: string,
      endtime?: string,
      page?: number,
      pagelength?: number,
      boundary?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling httpGetPersistenceItemData.'
        );
      }
      const localVarPath = `/persistence/items/{itemname}`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serviceId !== undefined) {
        localVarQueryParameter.serviceId = serviceId;
      }

      if (starttime !== undefined) {
        localVarQueryParameter.starttime = starttime;
      }

      if (endtime !== undefined) {
        localVarQueryParameter.endtime = endtime;
      }

      if (page !== undefined) {
        localVarQueryParameter.page = page;
      }

      if (pagelength !== undefined) {
        localVarQueryParameter.pagelength = pagelength;
      }

      if (boundary !== undefined) {
        localVarQueryParameter.boundary = boundary;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets a list of items available via a specific persistence service.
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceServiceItems(serviceId?: string, options: any = {}): FetchArgs {
      const localVarPath = `/persistence/items`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serviceId !== undefined) {
        localVarQueryParameter.serviceId = serviceId;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets a list of persistence services.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceServices(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/persistence`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Stores item persistence data into the persistence service.
     * @param {string} itemname The item name.
     * @param {string} time Time of the data to be stored. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} state The state to store.
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpPutPersistenceItemData(
      itemname: string,
      time: string,
      state: string,
      serviceId?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'itemname' is not null or undefined
      if (itemname === null || itemname === undefined) {
        throw new RequiredError(
          'itemname',
          'Required parameter itemname was null or undefined when calling httpPutPersistenceItemData.'
        );
      }
      // verify required parameter 'time' is not null or undefined
      if (time === null || time === undefined) {
        throw new RequiredError(
          'time',
          'Required parameter time was null or undefined when calling httpPutPersistenceItemData.'
        );
      }
      // verify required parameter 'state' is not null or undefined
      if (state === null || state === undefined) {
        throw new RequiredError(
          'state',
          'Required parameter state was null or undefined when calling httpPutPersistenceItemData.'
        );
      }
      const localVarPath = `/persistence/items/{itemname}`.replace(
        `{${'itemname'}}`,
        encodeURIComponent(String(itemname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serviceId !== undefined) {
        localVarQueryParameter.serviceId = serviceId;
      }

      if (time !== undefined) {
        localVarQueryParameter.time = time;
      }

      if (state !== undefined) {
        localVarQueryParameter.state = state;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * PersistenceApi - functional programming interface
 * @export
 */
export const PersistenceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete item data from a specific persistence service.
     * @param {string} serviceId Id of the persistence service.
     * @param {string} itemname The item name.
     * @param {string} starttime Start time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} endtime End time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpDeletePersistenceServiceItem(
      serviceId: string,
      itemname: string,
      starttime: string,
      endtime: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = PersistenceApiFetchParamCreator(
        configuration
      ).httpDeletePersistenceServiceItem(serviceId, itemname, starttime, endtime, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets item persistence data from the persistence service.
     * @param {string} itemname The item name
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {string} [starttime] Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} [endtime] End time of the data to return. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {number} [page] Page number of data to return. This parameter will enable paging.
     * @param {number} [pagelength] The length of each page.
     * @param {boolean} [boundary] Gets one value before and after the requested period.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceItemData(
      itemname: string,
      serviceId?: string,
      starttime?: string,
      endtime?: string,
      page?: number,
      pagelength?: number,
      boundary?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ItemHistoryDTO> {
      const localVarFetchArgs = PersistenceApiFetchParamCreator(
        configuration
      ).httpGetPersistenceItemData(
        itemname,
        serviceId,
        starttime,
        endtime,
        page,
        pagelength,
        boundary,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets a list of items available via a specific persistence service.
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceServiceItems(
      serviceId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = PersistenceApiFetchParamCreator(
        configuration
      ).httpGetPersistenceServiceItems(serviceId, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets a list of persistence services.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceServices(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = PersistenceApiFetchParamCreator(
        configuration
      ).httpGetPersistenceServices(acceptLanguage, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Stores item persistence data into the persistence service.
     * @param {string} itemname The item name.
     * @param {string} time Time of the data to be stored. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} state The state to store.
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpPutPersistenceItemData(
      itemname: string,
      time: string,
      state: string,
      serviceId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ItemHistoryDTO> {
      const localVarFetchArgs = PersistenceApiFetchParamCreator(
        configuration
      ).httpPutPersistenceItemData(itemname, time, state, serviceId, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * PersistenceApi - factory interface
 * @export
 */
export const PersistenceApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete item data from a specific persistence service.
     * @param {string} serviceId Id of the persistence service.
     * @param {string} itemname The item name.
     * @param {string} starttime Start time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} endtime End time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpDeletePersistenceServiceItem(
      serviceId: string,
      itemname: string,
      starttime: string,
      endtime: string,
      options?: any
    ) {
      return PersistenceApiFp(configuration).httpDeletePersistenceServiceItem(
        serviceId,
        itemname,
        starttime,
        endtime,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets item persistence data from the persistence service.
     * @param {string} itemname The item name
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {string} [starttime] Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} [endtime] End time of the data to return. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {number} [page] Page number of data to return. This parameter will enable paging.
     * @param {number} [pagelength] The length of each page.
     * @param {boolean} [boundary] Gets one value before and after the requested period.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceItemData(
      itemname: string,
      serviceId?: string,
      starttime?: string,
      endtime?: string,
      page?: number,
      pagelength?: number,
      boundary?: boolean,
      options?: any
    ) {
      return PersistenceApiFp(configuration).httpGetPersistenceItemData(
        itemname,
        serviceId,
        starttime,
        endtime,
        page,
        pagelength,
        boundary,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets a list of items available via a specific persistence service.
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceServiceItems(serviceId?: string, options?: any) {
      return PersistenceApiFp(configuration).httpGetPersistenceServiceItems(serviceId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Gets a list of persistence services.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpGetPersistenceServices(acceptLanguage?: string, options?: any) {
      return PersistenceApiFp(configuration).httpGetPersistenceServices(acceptLanguage, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Stores item persistence data into the persistence service.
     * @param {string} itemname The item name.
     * @param {string} time Time of the data to be stored. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {string} state The state to store.
     * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    httpPutPersistenceItemData(
      itemname: string,
      time: string,
      state: string,
      serviceId?: string,
      options?: any
    ) {
      return PersistenceApiFp(configuration).httpPutPersistenceItemData(
        itemname,
        time,
        state,
        serviceId,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * PersistenceApi - interface
 * @export
 * @interface PersistenceApi
 */
export interface PersistenceApiInterface {
  /**
   *
   * @summary Delete item data from a specific persistence service.
   * @param {string} serviceId Id of the persistence service.
   * @param {string} itemname The item name.
   * @param {string} starttime Start time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {string} endtime End time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApiInterface
   */
  httpDeletePersistenceServiceItem(
    serviceId: string,
    itemname: string,
    starttime: string,
    endtime: string,
    options?: any
  ): Promise<Array<string>>;

  /**
   *
   * @summary Gets item persistence data from the persistence service.
   * @param {string} itemname The item name
   * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
   * @param {string} [starttime] Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {string} [endtime] End time of the data to return. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {number} [page] Page number of data to return. This parameter will enable paging.
   * @param {number} [pagelength] The length of each page.
   * @param {boolean} [boundary] Gets one value before and after the requested period.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApiInterface
   */
  httpGetPersistenceItemData(
    itemname: string,
    serviceId?: string,
    starttime?: string,
    endtime?: string,
    page?: number,
    pagelength?: number,
    boundary?: boolean,
    options?: any
  ): Promise<ItemHistoryDTO>;

  /**
   *
   * @summary Gets a list of items available via a specific persistence service.
   * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApiInterface
   */
  httpGetPersistenceServiceItems(serviceId?: string, options?: any): Promise<Array<string>>;

  /**
   *
   * @summary Gets a list of persistence services.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApiInterface
   */
  httpGetPersistenceServices(acceptLanguage?: string, options?: any): Promise<Array<string>>;

  /**
   *
   * @summary Stores item persistence data into the persistence service.
   * @param {string} itemname The item name.
   * @param {string} time Time of the data to be stored. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {string} state The state to store.
   * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApiInterface
   */
  httpPutPersistenceItemData(
    itemname: string,
    time: string,
    state: string,
    serviceId?: string,
    options?: any
  ): Promise<ItemHistoryDTO>;
}

/**
 * PersistenceApi - object-oriented interface
 * @export
 * @class PersistenceApi
 * @extends {BaseAPI}
 */
export class PersistenceApi extends BaseAPI implements PersistenceApiInterface {
  /**
   *
   * @summary Delete item data from a specific persistence service.
   * @param {string} serviceId Id of the persistence service.
   * @param {string} itemname The item name.
   * @param {string} starttime Start time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {string} endtime End time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApi
   */
  public httpDeletePersistenceServiceItem(
    serviceId: string,
    itemname: string,
    starttime: string,
    endtime: string,
    options?: any
  ) {
    return PersistenceApiFp(this.configuration).httpDeletePersistenceServiceItem(
      serviceId,
      itemname,
      starttime,
      endtime,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets item persistence data from the persistence service.
   * @param {string} itemname The item name
   * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
   * @param {string} [starttime] Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {string} [endtime] End time of the data to return. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {number} [page] Page number of data to return. This parameter will enable paging.
   * @param {number} [pagelength] The length of each page.
   * @param {boolean} [boundary] Gets one value before and after the requested period.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApi
   */
  public httpGetPersistenceItemData(
    itemname: string,
    serviceId?: string,
    starttime?: string,
    endtime?: string,
    page?: number,
    pagelength?: number,
    boundary?: boolean,
    options?: any
  ) {
    return PersistenceApiFp(this.configuration).httpGetPersistenceItemData(
      itemname,
      serviceId,
      starttime,
      endtime,
      page,
      pagelength,
      boundary,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets a list of items available via a specific persistence service.
   * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApi
   */
  public httpGetPersistenceServiceItems(serviceId?: string, options?: any) {
    return PersistenceApiFp(this.configuration).httpGetPersistenceServiceItems(serviceId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets a list of persistence services.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApi
   */
  public httpGetPersistenceServices(acceptLanguage?: string, options?: any) {
    return PersistenceApiFp(this.configuration).httpGetPersistenceServices(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Stores item persistence data into the persistence service.
   * @param {string} itemname The item name.
   * @param {string} time Time of the data to be stored. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
   * @param {string} state The state to store.
   * @param {string} [serviceId] Id of the persistence service. If not provided the default service will be used
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersistenceApi
   */
  public httpPutPersistenceItemData(
    itemname: string,
    time: string,
    state: string,
    serviceId?: string,
    options?: any
  ) {
    return PersistenceApiFp(this.configuration).httpPutPersistenceItemData(
      itemname,
      time,
      state,
      serviceId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ProfileTypesApi - fetch parameter creator
 * @export
 */
export const ProfileTypesApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available profile types.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {string} [channelTypeUID] channel type filter
     * @param {string} [itemType] item type filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      acceptLanguage?: string,
      channelTypeUID?: string,
      itemType?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/profile-types`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (channelTypeUID !== undefined) {
        localVarQueryParameter.channelTypeUID = channelTypeUID;
      }

      if (itemType !== undefined) {
        localVarQueryParameter.itemType = itemType;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ProfileTypesApi - functional programming interface
 * @export
 */
export const ProfileTypesApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available profile types.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {string} [channelTypeUID] channel type filter
     * @param {string} [itemType] item type filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      acceptLanguage?: string,
      channelTypeUID?: string,
      itemType?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProfileTypeDTO>> {
      const localVarFetchArgs = ProfileTypesApiFetchParamCreator(configuration).getAll(
        acceptLanguage,
        channelTypeUID,
        itemType,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * ProfileTypesApi - factory interface
 * @export
 */
export const ProfileTypesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets all available profile types.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {string} [channelTypeUID] channel type filter
     * @param {string} [itemType] item type filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, channelTypeUID?: string, itemType?: string, options?: any) {
      return ProfileTypesApiFp(configuration).getAll(
        acceptLanguage,
        channelTypeUID,
        itemType,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * ProfileTypesApi - interface
 * @export
 * @interface ProfileTypesApi
 */
export interface ProfileTypesApiInterface {
  /**
   *
   * @summary Gets all available profile types.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {string} [channelTypeUID] channel type filter
   * @param {string} [itemType] item type filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileTypesApiInterface
   */
  getAll(
    acceptLanguage?: string,
    channelTypeUID?: string,
    itemType?: string,
    options?: any
  ): Promise<Array<ProfileTypeDTO>>;
}

/**
 * ProfileTypesApi - object-oriented interface
 * @export
 * @class ProfileTypesApi
 * @extends {BaseAPI}
 */
export class ProfileTypesApi extends BaseAPI implements ProfileTypesApiInterface {
  /**
   *
   * @summary Gets all available profile types.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {string} [channelTypeUID] channel type filter
   * @param {string} [itemType] item type filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileTypesApi
   */
  public getAll(
    acceptLanguage?: string,
    channelTypeUID?: string,
    itemType?: string,
    options?: any
  ) {
    return ProfileTypesApiFp(this.configuration).getAll(
      acceptLanguage,
      channelTypeUID,
      itemType,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ServicesApi - fetch parameter creator
 * @export
 */
export const ServicesApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Deletes a service configuration for given service ID and returns the old configuration.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfiguration(serviceId: string, options: any = {}): FetchArgs {
      // verify required parameter 'serviceId' is not null or undefined
      if (serviceId === null || serviceId === undefined) {
        throw new RequiredError(
          'serviceId',
          'Required parameter serviceId was null or undefined when calling deleteConfiguration.'
        );
      }
      const localVarPath = `/services/{serviceId}/config`.replace(
        `{${'serviceId'}}`,
        encodeURIComponent(String(serviceId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get all configurable services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options: any = {}): FetchArgs {
      const localVarPath = `/services`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get configurable service for given service ID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById(serviceId: string, options: any = {}): FetchArgs {
      // verify required parameter 'serviceId' is not null or undefined
      if (serviceId === null || serviceId === undefined) {
        throw new RequiredError(
          'serviceId',
          'Required parameter serviceId was null or undefined when calling getById.'
        );
      }
      const localVarPath = `/services/{serviceId}`.replace(
        `{${'serviceId'}}`,
        encodeURIComponent(String(serviceId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get service configuration for given service ID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(serviceId: string, options: any = {}): FetchArgs {
      // verify required parameter 'serviceId' is not null or undefined
      if (serviceId === null || serviceId === undefined) {
        throw new RequiredError(
          'serviceId',
          'Required parameter serviceId was null or undefined when calling getConfiguration.'
        );
      }
      const localVarPath = `/services/{serviceId}/config`.replace(
        `{${'serviceId'}}`,
        encodeURIComponent(String(serviceId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get existing multiple context service configurations for the given factory PID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultiConfigServicesByFactoryPid(serviceId: string, options: any = {}): FetchArgs {
      // verify required parameter 'serviceId' is not null or undefined
      if (serviceId === null || serviceId === undefined) {
        throw new RequiredError(
          'serviceId',
          'Required parameter serviceId was null or undefined when calling getMultiConfigServicesByFactoryPid.'
        );
      }
      const localVarPath = `/services/{serviceId}/contexts`.replace(
        `{${'serviceId'}}`,
        encodeURIComponent(String(serviceId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Updates a service configuration for given service ID and returns the old configuration.
     * @param {string} serviceId service ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(serviceId: string, body?: any, options: any = {}): FetchArgs {
      // verify required parameter 'serviceId' is not null or undefined
      if (serviceId === null || serviceId === undefined) {
        throw new RequiredError(
          'serviceId',
          'Required parameter serviceId was null or undefined when calling updateConfiguration.'
        );
      }
      const localVarPath = `/services/{serviceId}/config`.replace(
        `{${'serviceId'}}`,
        encodeURIComponent(String(serviceId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'any' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Deletes a service configuration for given service ID and returns the old configuration.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfiguration(
      serviceId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ServicesApiFetchParamCreator(configuration).deleteConfiguration(
        serviceId,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get all configurable services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConfigurableServiceDTO>> {
      const localVarFetchArgs = ServicesApiFetchParamCreator(configuration).getAll(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get configurable service for given service ID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById(
      serviceId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ConfigurableServiceDTO> {
      const localVarFetchArgs = ServicesApiFetchParamCreator(configuration).getById(
        serviceId,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get service configuration for given service ID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(
      serviceId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ServicesApiFetchParamCreator(configuration).getConfiguration(
        serviceId,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get existing multiple context service configurations for the given factory PID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultiConfigServicesByFactoryPid(
      serviceId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConfigurableServiceDTO>> {
      const localVarFetchArgs = ServicesApiFetchParamCreator(
        configuration
      ).getMultiConfigServicesByFactoryPid(serviceId, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Updates a service configuration for given service ID and returns the old configuration.
     * @param {string} serviceId service ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(
      serviceId: string,
      body?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ServicesApiFetchParamCreator(configuration).updateConfiguration(
        serviceId,
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Deletes a service configuration for given service ID and returns the old configuration.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfiguration(serviceId: string, options?: any) {
      return ServicesApiFp(configuration).deleteConfiguration(serviceId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get all configurable services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(options?: any) {
      return ServicesApiFp(configuration).getAll(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get configurable service for given service ID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById(serviceId: string, options?: any) {
      return ServicesApiFp(configuration).getById(serviceId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get service configuration for given service ID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(serviceId: string, options?: any) {
      return ServicesApiFp(configuration).getConfiguration(serviceId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get existing multiple context service configurations for the given factory PID.
     * @param {string} serviceId service ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultiConfigServicesByFactoryPid(serviceId: string, options?: any) {
      return ServicesApiFp(configuration).getMultiConfigServicesByFactoryPid(serviceId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Updates a service configuration for given service ID and returns the old configuration.
     * @param {string} serviceId service ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(serviceId: string, body?: any, options?: any) {
      return ServicesApiFp(configuration).updateConfiguration(
        serviceId,
        body,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * ServicesApi - interface
 * @export
 * @interface ServicesApi
 */
export interface ServicesApiInterface {
  /**
   *
   * @summary Deletes a service configuration for given service ID and returns the old configuration.
   * @param {string} serviceId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApiInterface
   */
  deleteConfiguration(serviceId: string, options?: any): Promise<string>;

  /**
   *
   * @summary Get all configurable services.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApiInterface
   */
  getAll(options?: any): Promise<Array<ConfigurableServiceDTO>>;

  /**
   *
   * @summary Get configurable service for given service ID.
   * @param {string} serviceId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApiInterface
   */
  getById(serviceId: string, options?: any): Promise<ConfigurableServiceDTO>;

  /**
   *
   * @summary Get service configuration for given service ID.
   * @param {string} serviceId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApiInterface
   */
  getConfiguration(serviceId: string, options?: any): Promise<string>;

  /**
   *
   * @summary Get existing multiple context service configurations for the given factory PID.
   * @param {string} serviceId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApiInterface
   */
  getMultiConfigServicesByFactoryPid(
    serviceId: string,
    options?: any
  ): Promise<Array<ConfigurableServiceDTO>>;

  /**
   *
   * @summary Updates a service configuration for given service ID and returns the old configuration.
   * @param {string} serviceId service ID
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApiInterface
   */
  updateConfiguration(serviceId: string, body?: any, options?: any): Promise<string>;
}

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI implements ServicesApiInterface {
  /**
   *
   * @summary Deletes a service configuration for given service ID and returns the old configuration.
   * @param {string} serviceId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public deleteConfiguration(serviceId: string, options?: any) {
    return ServicesApiFp(this.configuration).deleteConfiguration(serviceId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get all configurable services.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getAll(options?: any) {
    return ServicesApiFp(this.configuration).getAll(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get configurable service for given service ID.
   * @param {string} serviceId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getById(serviceId: string, options?: any) {
    return ServicesApiFp(this.configuration).getById(serviceId, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get service configuration for given service ID.
   * @param {string} serviceId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getConfiguration(serviceId: string, options?: any) {
    return ServicesApiFp(this.configuration).getConfiguration(serviceId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get existing multiple context service configurations for the given factory PID.
   * @param {string} serviceId service ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getMultiConfigServicesByFactoryPid(serviceId: string, options?: any) {
    return ServicesApiFp(this.configuration).getMultiConfigServicesByFactoryPid(serviceId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Updates a service configuration for given service ID and returns the old configuration.
   * @param {string} serviceId service ID
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public updateConfiguration(serviceId: string, body?: any, options?: any) {
    return ServicesApiFp(this.configuration).updateConfiguration(
      serviceId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SitemapsApi - fetch parameter creator
 * @export
 */
export const SitemapsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Creates a sitemap event subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventSubscription(options: any = {}): FetchArgs {
      const localVarPath = `/sitemaps/events/subscribe`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Polls the data for a sitemap.
     * @param {string} sitemapname sitemap name
     * @param {string} pageid page id
     * @param {string} [acceptLanguage] language
     * @param {string} [subscriptionid] subscriptionid
     * @param {boolean} [includeHidden] include hidden widgets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageData(
      sitemapname: string,
      pageid: string,
      acceptLanguage?: string,
      subscriptionid?: string,
      includeHidden?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'sitemapname' is not null or undefined
      if (sitemapname === null || sitemapname === undefined) {
        throw new RequiredError(
          'sitemapname',
          'Required parameter sitemapname was null or undefined when calling getPageData.'
        );
      }
      // verify required parameter 'pageid' is not null or undefined
      if (pageid === null || pageid === undefined) {
        throw new RequiredError(
          'pageid',
          'Required parameter pageid was null or undefined when calling getPageData.'
        );
      }
      const localVarPath = `/sitemaps/{sitemapname}/{pageid}`
        .replace(`{${'sitemapname'}}`, encodeURIComponent(String(sitemapname)))
        .replace(`{${'pageid'}}`, encodeURIComponent(String(pageid)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (subscriptionid !== undefined) {
        localVarQueryParameter.subscriptionid = subscriptionid;
      }

      if (includeHidden !== undefined) {
        localVarQueryParameter.includeHidden = includeHidden;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get sitemap by name.
     * @param {string} sitemapname sitemap name
     * @param {string} [acceptLanguage] language
     * @param {string} [type]
     * @param {string} [jsoncallback]
     * @param {boolean} [includeHidden] include hidden widgets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemapData(
      sitemapname: string,
      acceptLanguage?: string,
      type?: string,
      jsoncallback?: string,
      includeHidden?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'sitemapname' is not null or undefined
      if (sitemapname === null || sitemapname === undefined) {
        throw new RequiredError(
          'sitemapname',
          'Required parameter sitemapname was null or undefined when calling getSitemapData.'
        );
      }
      const localVarPath = `/sitemaps/{sitemapname}`.replace(
        `{${'sitemapname'}}`,
        encodeURIComponent(String(sitemapname))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type !== undefined) {
        localVarQueryParameter.type = type;
      }

      if (jsoncallback !== undefined) {
        localVarQueryParameter.jsoncallback = jsoncallback;
      }

      if (includeHidden !== undefined) {
        localVarQueryParameter.includeHidden = includeHidden;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get sitemap events.
     * @param {string} subscriptionid subscription id
     * @param {string} [sitemap] sitemap name
     * @param {string} [pageid] page id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemapEvents(
      subscriptionid: string,
      sitemap?: string,
      pageid?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'subscriptionid' is not null or undefined
      if (subscriptionid === null || subscriptionid === undefined) {
        throw new RequiredError(
          'subscriptionid',
          'Required parameter subscriptionid was null or undefined when calling getSitemapEvents.'
        );
      }
      const localVarPath = `/sitemaps/events/{subscriptionid}`.replace(
        `{${'subscriptionid'}}`,
        encodeURIComponent(String(subscriptionid))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sitemap !== undefined) {
        localVarQueryParameter.sitemap = sitemap;
      }

      if (pageid !== undefined) {
        localVarQueryParameter.pageid = pageid;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get all available sitemaps.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemaps(options: any = {}): FetchArgs {
      const localVarPath = `/sitemaps`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * SitemapsApi - functional programming interface
 * @export
 */
export const SitemapsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Creates a sitemap event subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventSubscription(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SitemapsApiFetchParamCreator(configuration).createEventSubscription(
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Polls the data for a sitemap.
     * @param {string} sitemapname sitemap name
     * @param {string} pageid page id
     * @param {string} [acceptLanguage] language
     * @param {string} [subscriptionid] subscriptionid
     * @param {boolean} [includeHidden] include hidden widgets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageData(
      sitemapname: string,
      pageid: string,
      acceptLanguage?: string,
      subscriptionid?: string,
      includeHidden?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SitemapsApiFetchParamCreator(configuration).getPageData(
        sitemapname,
        pageid,
        acceptLanguage,
        subscriptionid,
        includeHidden,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get sitemap by name.
     * @param {string} sitemapname sitemap name
     * @param {string} [acceptLanguage] language
     * @param {string} [type]
     * @param {string} [jsoncallback]
     * @param {boolean} [includeHidden] include hidden widgets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemapData(
      sitemapname: string,
      acceptLanguage?: string,
      type?: string,
      jsoncallback?: string,
      includeHidden?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SitemapsApiFetchParamCreator(configuration).getSitemapData(
        sitemapname,
        acceptLanguage,
        type,
        jsoncallback,
        includeHidden,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get sitemap events.
     * @param {string} subscriptionid subscription id
     * @param {string} [sitemap] sitemap name
     * @param {string} [pageid] page id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemapEvents(
      subscriptionid: string,
      sitemap?: string,
      pageid?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SitemapsApiFetchParamCreator(configuration).getSitemapEvents(
        subscriptionid,
        sitemap,
        pageid,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get all available sitemaps.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemaps(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SitemapsApiFetchParamCreator(configuration).getSitemaps(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * SitemapsApi - factory interface
 * @export
 */
export const SitemapsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Creates a sitemap event subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventSubscription(options?: any) {
      return SitemapsApiFp(configuration).createEventSubscription(options)(fetch, basePath);
    },
    /**
     *
     * @summary Polls the data for a sitemap.
     * @param {string} sitemapname sitemap name
     * @param {string} pageid page id
     * @param {string} [acceptLanguage] language
     * @param {string} [subscriptionid] subscriptionid
     * @param {boolean} [includeHidden] include hidden widgets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageData(
      sitemapname: string,
      pageid: string,
      acceptLanguage?: string,
      subscriptionid?: string,
      includeHidden?: boolean,
      options?: any
    ) {
      return SitemapsApiFp(configuration).getPageData(
        sitemapname,
        pageid,
        acceptLanguage,
        subscriptionid,
        includeHidden,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get sitemap by name.
     * @param {string} sitemapname sitemap name
     * @param {string} [acceptLanguage] language
     * @param {string} [type]
     * @param {string} [jsoncallback]
     * @param {boolean} [includeHidden] include hidden widgets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemapData(
      sitemapname: string,
      acceptLanguage?: string,
      type?: string,
      jsoncallback?: string,
      includeHidden?: boolean,
      options?: any
    ) {
      return SitemapsApiFp(configuration).getSitemapData(
        sitemapname,
        acceptLanguage,
        type,
        jsoncallback,
        includeHidden,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get sitemap events.
     * @param {string} subscriptionid subscription id
     * @param {string} [sitemap] sitemap name
     * @param {string} [pageid] page id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemapEvents(subscriptionid: string, sitemap?: string, pageid?: string, options?: any) {
      return SitemapsApiFp(configuration).getSitemapEvents(
        subscriptionid,
        sitemap,
        pageid,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all available sitemaps.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemaps(options?: any) {
      return SitemapsApiFp(configuration).getSitemaps(options)(fetch, basePath);
    }
  };
};

/**
 * SitemapsApi - interface
 * @export
 * @interface SitemapsApi
 */
export interface SitemapsApiInterface {
  /**
   *
   * @summary Creates a sitemap event subscription.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApiInterface
   */
  createEventSubscription(options?: any): Promise<any>;

  /**
   *
   * @summary Polls the data for a sitemap.
   * @param {string} sitemapname sitemap name
   * @param {string} pageid page id
   * @param {string} [acceptLanguage] language
   * @param {string} [subscriptionid] subscriptionid
   * @param {boolean} [includeHidden] include hidden widgets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApiInterface
   */
  getPageData(
    sitemapname: string,
    pageid: string,
    acceptLanguage?: string,
    subscriptionid?: string,
    includeHidden?: boolean,
    options?: any
  ): Promise<{}>;

  /**
   *
   * @summary Get sitemap by name.
   * @param {string} sitemapname sitemap name
   * @param {string} [acceptLanguage] language
   * @param {string} [type]
   * @param {string} [jsoncallback]
   * @param {boolean} [includeHidden] include hidden widgets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApiInterface
   */
  getSitemapData(
    sitemapname: string,
    acceptLanguage?: string,
    type?: string,
    jsoncallback?: string,
    includeHidden?: boolean,
    options?: any
  ): Promise<{}>;

  /**
   *
   * @summary Get sitemap events.
   * @param {string} subscriptionid subscription id
   * @param {string} [sitemap] sitemap name
   * @param {string} [pageid] page id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApiInterface
   */
  getSitemapEvents(
    subscriptionid: string,
    sitemap?: string,
    pageid?: string,
    options?: any
  ): Promise<{}>;

  /**
   *
   * @summary Get all available sitemaps.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApiInterface
   */
  getSitemaps(options?: any): Promise<{}>;
}

/**
 * SitemapsApi - object-oriented interface
 * @export
 * @class SitemapsApi
 * @extends {BaseAPI}
 */
export class SitemapsApi extends BaseAPI implements SitemapsApiInterface {
  /**
   *
   * @summary Creates a sitemap event subscription.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApi
   */
  public createEventSubscription(options?: any) {
    return SitemapsApiFp(this.configuration).createEventSubscription(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Polls the data for a sitemap.
   * @param {string} sitemapname sitemap name
   * @param {string} pageid page id
   * @param {string} [acceptLanguage] language
   * @param {string} [subscriptionid] subscriptionid
   * @param {boolean} [includeHidden] include hidden widgets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApi
   */
  public getPageData(
    sitemapname: string,
    pageid: string,
    acceptLanguage?: string,
    subscriptionid?: string,
    includeHidden?: boolean,
    options?: any
  ) {
    return SitemapsApiFp(this.configuration).getPageData(
      sitemapname,
      pageid,
      acceptLanguage,
      subscriptionid,
      includeHidden,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get sitemap by name.
   * @param {string} sitemapname sitemap name
   * @param {string} [acceptLanguage] language
   * @param {string} [type]
   * @param {string} [jsoncallback]
   * @param {boolean} [includeHidden] include hidden widgets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApi
   */
  public getSitemapData(
    sitemapname: string,
    acceptLanguage?: string,
    type?: string,
    jsoncallback?: string,
    includeHidden?: boolean,
    options?: any
  ) {
    return SitemapsApiFp(this.configuration).getSitemapData(
      sitemapname,
      acceptLanguage,
      type,
      jsoncallback,
      includeHidden,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get sitemap events.
   * @param {string} subscriptionid subscription id
   * @param {string} [sitemap] sitemap name
   * @param {string} [pageid] page id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApi
   */
  public getSitemapEvents(
    subscriptionid: string,
    sitemap?: string,
    pageid?: string,
    options?: any
  ) {
    return SitemapsApiFp(this.configuration).getSitemapEvents(
      subscriptionid,
      sitemap,
      pageid,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all available sitemaps.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitemapsApi
   */
  public getSitemaps(options?: any) {
    return SitemapsApiFp(this.configuration).getSitemaps(options)(this.fetch, this.basePath);
  }
}

/**
 * ThingTypesApi - fetch parameter creator
 * @export
 */
export const ThingTypesApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available thing types without config description, channels and properties.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/thing-types`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets thing type by UID.
     * @param {string} thingTypeUID thingTypeUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(thingTypeUID: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingTypeUID' is not null or undefined
      if (thingTypeUID === null || thingTypeUID === undefined) {
        throw new RequiredError(
          'thingTypeUID',
          'Required parameter thingTypeUID was null or undefined when calling getByUID.'
        );
      }
      const localVarPath = `/thing-types/{thingTypeUID}`.replace(
        `{${'thingTypeUID'}}`,
        encodeURIComponent(String(thingTypeUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ThingTypesApi - functional programming interface
 * @export
 */
export const ThingTypesApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets all available thing types without config description, channels and properties.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StrippedThingTypeDTO>> {
      const localVarFetchArgs = ThingTypesApiFetchParamCreator(configuration).getAll(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets thing type by UID.
     * @param {string} thingTypeUID thingTypeUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(
      thingTypeUID: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ThingTypeDTO> {
      const localVarFetchArgs = ThingTypesApiFetchParamCreator(configuration).getByUID(
        thingTypeUID,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * ThingTypesApi - factory interface
 * @export
 */
export const ThingTypesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets all available thing types without config description, channels and properties.
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options?: any) {
      return ThingTypesApiFp(configuration).getAll(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Gets thing type by UID.
     * @param {string} thingTypeUID thingTypeUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(thingTypeUID: string, acceptLanguage?: string, options?: any) {
      return ThingTypesApiFp(configuration).getByUID(
        thingTypeUID,
        acceptLanguage,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * ThingTypesApi - interface
 * @export
 * @interface ThingTypesApi
 */
export interface ThingTypesApiInterface {
  /**
   *
   * @summary Gets all available thing types without config description, channels and properties.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingTypesApiInterface
   */
  getAll(acceptLanguage?: string, options?: any): Promise<Array<StrippedThingTypeDTO>>;

  /**
   *
   * @summary Gets thing type by UID.
   * @param {string} thingTypeUID thingTypeUID
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingTypesApiInterface
   */
  getByUID(thingTypeUID: string, acceptLanguage?: string, options?: any): Promise<ThingTypeDTO>;
}

/**
 * ThingTypesApi - object-oriented interface
 * @export
 * @class ThingTypesApi
 * @extends {BaseAPI}
 */
export class ThingTypesApi extends BaseAPI implements ThingTypesApiInterface {
  /**
   *
   * @summary Gets all available thing types without config description, channels and properties.
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingTypesApi
   */
  public getAll(acceptLanguage?: string, options?: any) {
    return ThingTypesApiFp(this.configuration).getAll(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets thing type by UID.
   * @param {string} thingTypeUID thingTypeUID
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingTypesApi
   */
  public getByUID(thingTypeUID: string, acceptLanguage?: string, options?: any) {
    return ThingTypesApiFp(this.configuration).getByUID(
      thingTypeUID,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ThingsApi - fetch parameter creator
 * @export
 */
export const ThingsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Creates a new thing and adds it to the registry.
     * @param {ThingDTO} body thing data
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(body: ThingDTO, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling create.'
        );
      }
      const localVarPath = `/things`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'ThingDTO' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get all available things.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/things`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets thing by UID.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(thingUID: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling getByUID.'
        );
      }
      const localVarPath = `/things/{thingUID}`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets thing's config status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigStatus(thingUID: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling getConfigStatus.'
        );
      }
      const localVarPath = `/things/{thingUID}/config/status`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets thing's firmware status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFirmwareStatus(thingUID: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling getFirmwareStatus.'
        );
      }
      const localVarPath = `/things/{thingUID}/firmware/status`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get all available firmwares for provided thing UID
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFirmwares(thingUID: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling getFirmwares.'
        );
      }
      const localVarPath = `/things/{thingUID}/firmwares`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets thing's status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(thingUID: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling getStatus.'
        );
      }
      const localVarPath = `/things/{thingUID}/status`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Removes a thing from the registry. Set 'force' to __true__ if you want the thing te be removed immediately.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {boolean} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(
      thingUID: string,
      acceptLanguage?: string,
      force?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling remove.'
        );
      }
      const localVarPath = `/things/{thingUID}`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'DELETE', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (force !== undefined) {
        localVarQueryParameter.force = force;
      }

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Sets the thing enabled status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {string} [body] enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEnabled(
      thingUID: string,
      acceptLanguage?: string,
      body?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling setEnabled.'
        );
      }
      const localVarPath = `/things/{thingUID}/enable`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Updates a thing.
     * @param {string} thingUID thingUID
     * @param {ThingDTO} body thing
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      thingUID: string,
      body: ThingDTO,
      acceptLanguage?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling update.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling update.'
        );
      }
      const localVarPath = `/things/{thingUID}`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'ThingDTO' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Updates thing's configuration.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {any} [body] configuration parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(
      thingUID: string,
      acceptLanguage?: string,
      body?: any,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling updateConfiguration.'
        );
      }
      const localVarPath = `/things/{thingUID}/config`.replace(
        `{${'thingUID'}}`,
        encodeURIComponent(String(thingUID))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'any' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Update thing firmware.
     * @param {string} thingUID thing
     * @param {string} firmwareVersion version
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFirmware(
      thingUID: string,
      firmwareVersion: string,
      acceptLanguage?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'thingUID' is not null or undefined
      if (thingUID === null || thingUID === undefined) {
        throw new RequiredError(
          'thingUID',
          'Required parameter thingUID was null or undefined when calling updateFirmware.'
        );
      }
      // verify required parameter 'firmwareVersion' is not null or undefined
      if (firmwareVersion === null || firmwareVersion === undefined) {
        throw new RequiredError(
          'firmwareVersion',
          'Required parameter firmwareVersion was null or undefined when calling updateFirmware.'
        );
      }
      const localVarPath = `/things/{thingUID}/firmware/{firmwareVersion}`
        .replace(`{${'thingUID'}}`, encodeURIComponent(String(thingUID)))
        .replace(`{${'firmwareVersion'}}`, encodeURIComponent(String(firmwareVersion)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'PUT', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ThingsApi - functional programming interface
 * @export
 */
export const ThingsApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Creates a new thing and adds it to the registry.
     * @param {ThingDTO} body thing data
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      body: ThingDTO,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).create(
        body,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get all available things.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EnrichedThingDTO>> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).getAll(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets thing by UID.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(
      thingUID: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ThingDTO> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).getByUID(
        thingUID,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets thing's config status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigStatus(
      thingUID: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).getConfigStatus(
        thingUID,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets thing's firmware status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFirmwareStatus(
      thingUID: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).getFirmwareStatus(
        thingUID,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get all available firmwares for provided thing UID
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFirmwares(
      thingUID: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).getFirmwares(
        thingUID,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets thing's status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(
      thingUID: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).getStatus(
        thingUID,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Removes a thing from the registry. Set 'force' to __true__ if you want the thing te be removed immediately.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {boolean} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(
      thingUID: string,
      acceptLanguage?: string,
      force?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).remove(
        thingUID,
        acceptLanguage,
        force,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Sets the thing enabled status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {string} [body] enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEnabled(
      thingUID: string,
      acceptLanguage?: string,
      body?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).setEnabled(
        thingUID,
        acceptLanguage,
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Updates a thing.
     * @param {string} thingUID thingUID
     * @param {ThingDTO} body thing
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      thingUID: string,
      body: ThingDTO,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ThingDTO> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).update(
        thingUID,
        body,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Updates thing's configuration.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {any} [body] configuration parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(
      thingUID: string,
      acceptLanguage?: string,
      body?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ThingDTO> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).updateConfiguration(
        thingUID,
        acceptLanguage,
        body,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Update thing firmware.
     * @param {string} thingUID thing
     * @param {string} firmwareVersion version
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFirmware(
      thingUID: string,
      firmwareVersion: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ThingsApiFetchParamCreator(configuration).updateFirmware(
        thingUID,
        firmwareVersion,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * ThingsApi - factory interface
 * @export
 */
export const ThingsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Creates a new thing and adds it to the registry.
     * @param {ThingDTO} body thing data
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(body: ThingDTO, acceptLanguage?: string, options?: any) {
      return ThingsApiFp(configuration).create(body, acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get all available things.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(acceptLanguage?: string, options?: any) {
      return ThingsApiFp(configuration).getAll(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Gets thing by UID.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByUID(thingUID: string, acceptLanguage?: string, options?: any) {
      return ThingsApiFp(configuration).getByUID(
        thingUID,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets thing's config status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigStatus(thingUID: string, acceptLanguage?: string, options?: any) {
      return ThingsApiFp(configuration).getConfigStatus(
        thingUID,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets thing's firmware status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFirmwareStatus(thingUID: string, acceptLanguage?: string, options?: any) {
      return ThingsApiFp(configuration).getFirmwareStatus(
        thingUID,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all available firmwares for provided thing UID
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFirmwares(thingUID: string, acceptLanguage?: string, options?: any) {
      return ThingsApiFp(configuration).getFirmwares(
        thingUID,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets thing's status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(thingUID: string, acceptLanguage?: string, options?: any) {
      return ThingsApiFp(configuration).getStatus(
        thingUID,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Removes a thing from the registry. Set 'force' to __true__ if you want the thing te be removed immediately.
     * @param {string} thingUID thingUID
     * @param {string} [acceptLanguage] language
     * @param {boolean} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(thingUID: string, acceptLanguage?: string, force?: boolean, options?: any) {
      return ThingsApiFp(configuration).remove(
        thingUID,
        acceptLanguage,
        force,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the thing enabled status.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {string} [body] enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEnabled(thingUID: string, acceptLanguage?: string, body?: string, options?: any) {
      return ThingsApiFp(configuration).setEnabled(
        thingUID,
        acceptLanguage,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Updates a thing.
     * @param {string} thingUID thingUID
     * @param {ThingDTO} body thing
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(thingUID: string, body: ThingDTO, acceptLanguage?: string, options?: any) {
      return ThingsApiFp(configuration).update(
        thingUID,
        body,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Updates thing's configuration.
     * @param {string} thingUID thing
     * @param {string} [acceptLanguage]
     * @param {any} [body] configuration parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(thingUID: string, acceptLanguage?: string, body?: any, options?: any) {
      return ThingsApiFp(configuration).updateConfiguration(
        thingUID,
        acceptLanguage,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update thing firmware.
     * @param {string} thingUID thing
     * @param {string} firmwareVersion version
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFirmware(
      thingUID: string,
      firmwareVersion: string,
      acceptLanguage?: string,
      options?: any
    ) {
      return ThingsApiFp(configuration).updateFirmware(
        thingUID,
        firmwareVersion,
        acceptLanguage,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * ThingsApi - interface
 * @export
 * @interface ThingsApi
 */
export interface ThingsApiInterface {
  /**
   *
   * @summary Creates a new thing and adds it to the registry.
   * @param {ThingDTO} body thing data
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  create(body: ThingDTO, acceptLanguage?: string, options?: any): Promise<string>;

  /**
   *
   * @summary Get all available things.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  getAll(acceptLanguage?: string, options?: any): Promise<Array<EnrichedThingDTO>>;

  /**
   *
   * @summary Gets thing by UID.
   * @param {string} thingUID thingUID
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  getByUID(thingUID: string, acceptLanguage?: string, options?: any): Promise<ThingDTO>;

  /**
   *
   * @summary Gets thing's config status.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  getConfigStatus(thingUID: string, acceptLanguage?: string, options?: any): Promise<string>;

  /**
   *
   * @summary Gets thing's firmware status.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  getFirmwareStatus(thingUID: string, acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Get all available firmwares for provided thing UID
   * @param {string} thingUID thingUID
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  getFirmwares(thingUID: string, acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Gets thing's status.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  getStatus(thingUID: string, acceptLanguage?: string, options?: any): Promise<string>;

  /**
   *
   * @summary Removes a thing from the registry. Set 'force' to __true__ if you want the thing te be removed immediately.
   * @param {string} thingUID thingUID
   * @param {string} [acceptLanguage] language
   * @param {boolean} [force] force
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  remove(thingUID: string, acceptLanguage?: string, force?: boolean, options?: any): Promise<{}>;

  /**
   *
   * @summary Sets the thing enabled status.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {string} [body] enabled
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  setEnabled(
    thingUID: string,
    acceptLanguage?: string,
    body?: string,
    options?: any
  ): Promise<string>;

  /**
   *
   * @summary Updates a thing.
   * @param {string} thingUID thingUID
   * @param {ThingDTO} body thing
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  update(
    thingUID: string,
    body: ThingDTO,
    acceptLanguage?: string,
    options?: any
  ): Promise<ThingDTO>;

  /**
   *
   * @summary Updates thing's configuration.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {any} [body] configuration parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  updateConfiguration(
    thingUID: string,
    acceptLanguage?: string,
    body?: any,
    options?: any
  ): Promise<ThingDTO>;

  /**
   *
   * @summary Update thing firmware.
   * @param {string} thingUID thing
   * @param {string} firmwareVersion version
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApiInterface
   */
  updateFirmware(
    thingUID: string,
    firmwareVersion: string,
    acceptLanguage?: string,
    options?: any
  ): Promise<{}>;
}

/**
 * ThingsApi - object-oriented interface
 * @export
 * @class ThingsApi
 * @extends {BaseAPI}
 */
export class ThingsApi extends BaseAPI implements ThingsApiInterface {
  /**
   *
   * @summary Creates a new thing and adds it to the registry.
   * @param {ThingDTO} body thing data
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public create(body: ThingDTO, acceptLanguage?: string, options?: any) {
    return ThingsApiFp(this.configuration).create(
      body,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all available things.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public getAll(acceptLanguage?: string, options?: any) {
    return ThingsApiFp(this.configuration).getAll(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets thing by UID.
   * @param {string} thingUID thingUID
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public getByUID(thingUID: string, acceptLanguage?: string, options?: any) {
    return ThingsApiFp(this.configuration).getByUID(
      thingUID,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets thing's config status.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public getConfigStatus(thingUID: string, acceptLanguage?: string, options?: any) {
    return ThingsApiFp(this.configuration).getConfigStatus(
      thingUID,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets thing's firmware status.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public getFirmwareStatus(thingUID: string, acceptLanguage?: string, options?: any) {
    return ThingsApiFp(this.configuration).getFirmwareStatus(
      thingUID,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all available firmwares for provided thing UID
   * @param {string} thingUID thingUID
   * @param {string} [acceptLanguage] Accept-Language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public getFirmwares(thingUID: string, acceptLanguage?: string, options?: any) {
    return ThingsApiFp(this.configuration).getFirmwares(
      thingUID,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets thing's status.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public getStatus(thingUID: string, acceptLanguage?: string, options?: any) {
    return ThingsApiFp(this.configuration).getStatus(
      thingUID,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Removes a thing from the registry. Set 'force' to __true__ if you want the thing te be removed immediately.
   * @param {string} thingUID thingUID
   * @param {string} [acceptLanguage] language
   * @param {boolean} [force] force
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public remove(thingUID: string, acceptLanguage?: string, force?: boolean, options?: any) {
    return ThingsApiFp(this.configuration).remove(
      thingUID,
      acceptLanguage,
      force,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the thing enabled status.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {string} [body] enabled
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public setEnabled(thingUID: string, acceptLanguage?: string, body?: string, options?: any) {
    return ThingsApiFp(this.configuration).setEnabled(
      thingUID,
      acceptLanguage,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Updates a thing.
   * @param {string} thingUID thingUID
   * @param {ThingDTO} body thing
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public update(thingUID: string, body: ThingDTO, acceptLanguage?: string, options?: any) {
    return ThingsApiFp(this.configuration).update(
      thingUID,
      body,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Updates thing's configuration.
   * @param {string} thingUID thing
   * @param {string} [acceptLanguage]
   * @param {any} [body] configuration parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public updateConfiguration(thingUID: string, acceptLanguage?: string, body?: any, options?: any) {
    return ThingsApiFp(this.configuration).updateConfiguration(
      thingUID,
      acceptLanguage,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update thing firmware.
   * @param {string} thingUID thing
   * @param {string} firmwareVersion version
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThingsApi
   */
  public updateFirmware(
    thingUID: string,
    firmwareVersion: string,
    acceptLanguage?: string,
    options?: any
  ) {
    return ThingsApiFp(this.configuration).updateFirmware(
      thingUID,
      firmwareVersion,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * UuidApi - fetch parameter creator
 * @export
 */
export const UuidApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary A unified unique id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceUUID(options: any = {}): FetchArgs {
      const localVarPath = `/uuid`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * UuidApi - functional programming interface
 * @export
 */
export const UuidApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary A unified unique id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceUUID(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = UuidApiFetchParamCreator(configuration).getInstanceUUID(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          }
          throw response;
        });
      };
    }
  };
};

/**
 * UuidApi - factory interface
 * @export
 */
export const UuidApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary A unified unique id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceUUID(options?: any) {
      return UuidApiFp(configuration).getInstanceUUID(options)(fetch, basePath);
    }
  };
};

/**
 * UuidApi - interface
 * @export
 * @interface UuidApi
 */
export interface UuidApiInterface {
  /**
   *
   * @summary A unified unique id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UuidApiInterface
   */
  getInstanceUUID(options?: any): Promise<string>;
}

/**
 * UuidApi - object-oriented interface
 * @export
 * @class UuidApi
 * @extends {BaseAPI}
 */
export class UuidApi extends BaseAPI implements UuidApiInterface {
  /**
   *
   * @summary A unified unique id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UuidApi
   */
  public getInstanceUUID(options?: any) {
    return UuidApiFp(this.configuration).getInstanceUUID(options)(this.fetch, this.basePath);
  }
}

/**
 * VoiceApi - fetch parameter creator
 * @export
 */
export const VoiceApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets the default voice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultVoice(options: any = {}): FetchArgs {
      const localVarPath = `/voice/defaultvoice`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Gets a single interpreter.
     * @param {string} id interpreter id
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterpreter(id: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getInterpreter.'
        );
      }
      const localVarPath = `/voice/interpreters/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get the list of all interpreters.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterpreters(acceptLanguage?: string, options: any = {}): FetchArgs {
      const localVarPath = `/voice/interpreters`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get the list of all voices.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVoices(options: any = {}): FetchArgs {
      const localVarPath = `/voice/voices`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'GET', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Sends a text to the default human language interpreter.
     * @param {string} body text to interpret
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interpret(body: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling interpret.'
        );
      }
      const localVarPath = `/voice/interpreters`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Sends a text to a given human language interpreter.
     * @param {string} body text to interpret
     * @param {string} id interpreter id
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interpret_1(body: string, id: string, acceptLanguage?: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling interpret_1.'
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling interpret_1.'
        );
      }
      const localVarPath = `/voice/interpreters/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acceptLanguage !== undefined && acceptLanguage !== null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Speaks a given text with a given voice through the given audio sink.
     * @param {string} body text to speak
     * @param {string} [voiceid] voice id
     * @param {string} [sinkid] audio sink id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    say(body: string, voiceid?: string, sinkid?: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling say.'
        );
      }
      const localVarPath = `/voice/say`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = { method: 'POST', ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (voiceid !== undefined) {
        localVarQueryParameter.voiceid = voiceid;
      }

      if (sinkid !== undefined) {
        localVarQueryParameter.sinkid = sinkid;
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * VoiceApi - functional programming interface
 * @export
 */
export const VoiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets the default voice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultVoice(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VoiceApiFetchParamCreator(configuration).getDefaultVoice(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Gets a single interpreter.
     * @param {string} id interpreter id
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterpreter(
      id: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VoiceApiFetchParamCreator(configuration).getInterpreter(
        id,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get the list of all interpreters.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterpreters(
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VoiceApiFetchParamCreator(configuration).getInterpreters(
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Get the list of all voices.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVoices(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VoiceApiFetchParamCreator(configuration).getVoices(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Sends a text to the default human language interpreter.
     * @param {string} body text to interpret
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interpret(
      body: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VoiceApiFetchParamCreator(configuration).interpret(
        body,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Sends a text to a given human language interpreter.
     * @param {string} body text to interpret
     * @param {string} id interpreter id
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interpret_1(
      body: string,
      id: string,
      acceptLanguage?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VoiceApiFetchParamCreator(configuration).interpret_1(
        body,
        id,
        acceptLanguage,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    },
    /**
     *
     * @summary Speaks a given text with a given voice through the given audio sink.
     * @param {string} body text to speak
     * @param {string} [voiceid] voice id
     * @param {string} [sinkid] audio sink id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    say(
      body: string,
      voiceid?: string,
      sinkid?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = VoiceApiFetchParamCreator(configuration).say(
        body,
        voiceid,
        sinkid,
        options
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }
          throw response;
        });
      };
    }
  };
};

/**
 * VoiceApi - factory interface
 * @export
 */
export const VoiceApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets the default voice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultVoice(options?: any) {
      return VoiceApiFp(configuration).getDefaultVoice(options)(fetch, basePath);
    },
    /**
     *
     * @summary Gets a single interpreter.
     * @param {string} id interpreter id
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterpreter(id: string, acceptLanguage?: string, options?: any) {
      return VoiceApiFp(configuration).getInterpreter(id, acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get the list of all interpreters.
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterpreters(acceptLanguage?: string, options?: any) {
      return VoiceApiFp(configuration).getInterpreters(acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get the list of all voices.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVoices(options?: any) {
      return VoiceApiFp(configuration).getVoices(options)(fetch, basePath);
    },
    /**
     *
     * @summary Sends a text to the default human language interpreter.
     * @param {string} body text to interpret
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interpret(body: string, acceptLanguage?: string, options?: any) {
      return VoiceApiFp(configuration).interpret(body, acceptLanguage, options)(fetch, basePath);
    },
    /**
     *
     * @summary Sends a text to a given human language interpreter.
     * @param {string} body text to interpret
     * @param {string} id interpreter id
     * @param {string} [acceptLanguage] language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    interpret_1(body: string, id: string, acceptLanguage?: string, options?: any) {
      return VoiceApiFp(configuration).interpret_1(
        body,
        id,
        acceptLanguage,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Speaks a given text with a given voice through the given audio sink.
     * @param {string} body text to speak
     * @param {string} [voiceid] voice id
     * @param {string} [sinkid] audio sink id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    say(body: string, voiceid?: string, sinkid?: string, options?: any) {
      return VoiceApiFp(configuration).say(body, voiceid, sinkid, options)(fetch, basePath);
    }
  };
};

/**
 * VoiceApi - interface
 * @export
 * @interface VoiceApi
 */
export interface VoiceApiInterface {
  /**
   *
   * @summary Gets the default voice.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApiInterface
   */
  getDefaultVoice(options?: any): Promise<{}>;

  /**
   *
   * @summary Gets a single interpreter.
   * @param {string} id interpreter id
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApiInterface
   */
  getInterpreter(id: string, acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Get the list of all interpreters.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApiInterface
   */
  getInterpreters(acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Get the list of all voices.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApiInterface
   */
  getVoices(options?: any): Promise<{}>;

  /**
   *
   * @summary Sends a text to the default human language interpreter.
   * @param {string} body text to interpret
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApiInterface
   */
  interpret(body: string, acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Sends a text to a given human language interpreter.
   * @param {string} body text to interpret
   * @param {string} id interpreter id
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApiInterface
   */
  interpret_1(body: string, id: string, acceptLanguage?: string, options?: any): Promise<{}>;

  /**
   *
   * @summary Speaks a given text with a given voice through the given audio sink.
   * @param {string} body text to speak
   * @param {string} [voiceid] voice id
   * @param {string} [sinkid] audio sink id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApiInterface
   */
  say(body: string, voiceid?: string, sinkid?: string, options?: any): Promise<{}>;
}

/**
 * VoiceApi - object-oriented interface
 * @export
 * @class VoiceApi
 * @extends {BaseAPI}
 */
export class VoiceApi extends BaseAPI implements VoiceApiInterface {
  /**
   *
   * @summary Gets the default voice.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  public getDefaultVoice(options?: any) {
    return VoiceApiFp(this.configuration).getDefaultVoice(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets a single interpreter.
   * @param {string} id interpreter id
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  public getInterpreter(id: string, acceptLanguage?: string, options?: any) {
    return VoiceApiFp(this.configuration).getInterpreter(
      id,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the list of all interpreters.
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  public getInterpreters(acceptLanguage?: string, options?: any) {
    return VoiceApiFp(this.configuration).getInterpreters(acceptLanguage, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the list of all voices.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  public getVoices(options?: any) {
    return VoiceApiFp(this.configuration).getVoices(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sends a text to the default human language interpreter.
   * @param {string} body text to interpret
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  public interpret(body: string, acceptLanguage?: string, options?: any) {
    return VoiceApiFp(this.configuration).interpret(
      body,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sends a text to a given human language interpreter.
   * @param {string} body text to interpret
   * @param {string} id interpreter id
   * @param {string} [acceptLanguage] language
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  public interpret_1(body: string, id: string, acceptLanguage?: string, options?: any) {
    return VoiceApiFp(this.configuration).interpret_1(
      body,
      id,
      acceptLanguage,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Speaks a given text with a given voice through the given audio sink.
   * @param {string} body text to speak
   * @param {string} [voiceid] voice id
   * @param {string} [sinkid] audio sink id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  public say(body: string, voiceid?: string, sinkid?: string, options?: any) {
    return VoiceApiFp(this.configuration).say(
      body,
      voiceid,
      sinkid,
      options
    )(this.fetch, this.basePath);
  }
}
